<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Transient Recorder Framework: TRBaseDriver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Transient Recorder Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTRBaseDriver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TRBaseDriver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Central class of the Transient Recorder framework for transient recorders (digitizers).  
 <a href="classTRBaseDriver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TRBaseDriver_8h_source.html">TRBaseDriver.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TRBaseDriver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classTRBaseDriver.png" usemap="#TRBaseDriver_map" alt=""/>
  <map id="TRBaseDriver_map" name="TRBaseDriver_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a712657c4e9bda0315f0b44473690a2db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a712657c4e9bda0315f0b44473690a2db">TRBaseDriver</a> (<a class="el" href="classTRBaseConfig.html">TRBaseConfig</a> const &amp;cfg)</td></tr>
<tr class="memdesc:a712657c4e9bda0315f0b44473690a2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="classTRBaseDriver.html" title="Central class of the Transient Recorder framework for transient recorders (digitizers). ">TRBaseDriver</a>, to be used from constructors of derived classes.  <a href="#a712657c4e9bda0315f0b44473690a2db">More...</a><br /></td></tr>
<tr class="separator:a712657c4e9bda0315f0b44473690a2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffec79dcf8c5fb8ba5ffd3ce87c121f"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename EffectiveValueType &gt; </td></tr>
<tr class="memitem:a1ffec79dcf8c5fb8ba5ffd3ce87c121f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a1ffec79dcf8c5fb8ba5ffd3ce87c121f">initConfigParam</a> (<a class="el" href="classTRConfigParam.html">TRConfigParam</a>&lt; ValueType, EffectiveValueType &gt; &amp;param, char const *base_name, EffectiveValueType invalid_value=EffectiveValueType())</td></tr>
<tr class="memdesc:a1ffec79dcf8c5fb8ba5ffd3ce87c121f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a configuration parameter.  <a href="#a1ffec79dcf8c5fb8ba5ffd3ce87c121f">More...</a><br /></td></tr>
<tr class="separator:a1ffec79dcf8c5fb8ba5ffd3ce87c121f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017dc1a597090971fdcc6fa5e466b2b5"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename EffectiveValueType &gt; </td></tr>
<tr class="memitem:a017dc1a597090971fdcc6fa5e466b2b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a017dc1a597090971fdcc6fa5e466b2b5">initInternalParam</a> (<a class="el" href="classTRConfigParam.html">TRConfigParam</a>&lt; ValueType, EffectiveValueType &gt; &amp;param, char const *base_name, EffectiveValueType invalid_value=EffectiveValueType())</td></tr>
<tr class="memdesc:a017dc1a597090971fdcc6fa5e466b2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an internal configration parameter.  <a href="#a017dc1a597090971fdcc6fa5e466b2b5">More...</a><br /></td></tr>
<tr class="separator:a017dc1a597090971fdcc6fa5e466b2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5578f3d5e8961ab24cb85aa12762df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a2b5578f3d5e8961ab24cb85aa12762df">completeInit</a> ()</td></tr>
<tr class="memdesc:a2b5578f3d5e8961ab24cb85aa12762df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete initialization of the class.  <a href="#a2b5578f3d5e8961ab24cb85aa12762df">More...</a><br /></td></tr>
<tr class="separator:a2b5578f3d5e8961ab24cb85aa12762df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f5747bad2e87db7148f2e52a132523"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTRChannelsDriver.html">TRChannelsDriver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#ad0f5747bad2e87db7148f2e52a132523">getChannelsDriver</a> ()</td></tr>
<tr class="memdesc:ad0f5747bad2e87db7148f2e52a132523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the channels driver.  <a href="#ad0f5747bad2e87db7148f2e52a132523">More...</a><br /></td></tr>
<tr class="separator:ad0f5747bad2e87db7148f2e52a132523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafad865f171e12b63b97e642ad59aae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#aafad865f171e12b63b97e642ad59aae4">setDigitizerName</a> (char const *name)</td></tr>
<tr class="memdesc:aafad865f171e12b63b97e642ad59aae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the digitizer, which will appear as the value of the "name" PV.  <a href="#aafad865f171e12b63b97e642ad59aae4">More...</a><br /></td></tr>
<tr class="separator:aafad865f171e12b63b97e642ad59aae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f98559d9a9208e18c7438bec648f6a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a94f98559d9a9208e18c7438bec648f6a">getRequestedSampleRate</a> ()</td></tr>
<tr class="memdesc:a94f98559d9a9208e18c7438bec648f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested sample rate.  <a href="#a94f98559d9a9208e18c7438bec648f6a">More...</a><br /></td></tr>
<tr class="separator:a94f98559d9a9208e18c7438bec648f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f2a60d33275dc1ca9d9bfd03edc9b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a43f2a60d33275dc1ca9d9bfd03edc9b5">setAchievableSampleRate</a> (double value)</td></tr>
<tr class="memdesc:a43f2a60d33275dc1ca9d9bfd03edc9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the achievable sample rate corresponding to the requested sample rate.  <a href="#a43f2a60d33275dc1ca9d9bfd03edc9b5">More...</a><br /></td></tr>
<tr class="separator:a43f2a60d33275dc1ca9d9bfd03edc9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e63889bd84f60be719d15dfd405ab4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a6e63889bd84f60be719d15dfd405ab4d">getNumBurstsSnapshot</a> ()</td></tr>
<tr class="memdesc:a6e63889bd84f60be719d15dfd405ab4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the snapshot value of the number of bursts to capture.  <a href="#a6e63889bd84f60be719d15dfd405ab4d">More...</a><br /></td></tr>
<tr class="separator:a6e63889bd84f60be719d15dfd405ab4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64d62a21e6555851c8c85b9942579b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#ad64d62a21e6555851c8c85b9942579b9">getNumPostSamplesSnapshot</a> ()</td></tr>
<tr class="memdesc:ad64d62a21e6555851c8c85b9942579b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the snapshot value of the number of post-trigger samples per event.  <a href="#ad64d62a21e6555851c8c85b9942579b9">More...</a><br /></td></tr>
<tr class="separator:ad64d62a21e6555851c8c85b9942579b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bd33f4704b42fe5c6255f86e563db8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a43bd33f4704b42fe5c6255f86e563db8">getNumPrePostSamplesSnapshot</a> ()</td></tr>
<tr class="memdesc:a43bd33f4704b42fe5c6255f86e563db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the snapshot value for the total number of samples per event (counting pre-trigger and post-trigger samples).  <a href="#a43bd33f4704b42fe5c6255f86e563db8">More...</a><br /></td></tr>
<tr class="separator:a43bd33f4704b42fe5c6255f86e563db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b6399f6598270f2f1ccf899f9652cb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a50b6399f6598270f2f1ccf899f9652cb">getRequestedSampleRateSnapshot</a> ()</td></tr>
<tr class="memdesc:a50b6399f6598270f2f1ccf899f9652cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the snapshot value of the requested sample rate.  <a href="#a50b6399f6598270f2f1ccf899f9652cb">More...</a><br /></td></tr>
<tr class="separator:a50b6399f6598270f2f1ccf899f9652cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82a97ddd260bf97b0ccfba5b620b4ab"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#aa82a97ddd260bf97b0ccfba5b620b4ab">getAchievableSampleRateSnapshot</a> ()</td></tr>
<tr class="memdesc:aa82a97ddd260bf97b0ccfba5b620b4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the snapshot value of the achievable sample rate.  <a href="#aa82a97ddd260bf97b0ccfba5b620b4ab">More...</a><br /></td></tr>
<tr class="separator:aa82a97ddd260bf97b0ccfba5b620b4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26e54e4756b4255d88b2e894967fe02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#ab26e54e4756b4255d88b2e894967fe02">requestDisarmingFromDriver</a> ()</td></tr>
<tr class="memdesc:ab26e54e4756b4255d88b2e894967fe02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request disarming of acquisition.  <a href="#ab26e54e4756b4255d88b2e894967fe02">More...</a><br /></td></tr>
<tr class="separator:ab26e54e4756b4255d88b2e894967fe02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e12c5814534c930a6aa7073d3dfe3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a67e12c5814534c930a6aa7073d3dfe3b">publishBurstMetaInfo</a> (<a class="el" href="classTRBurstMetaInfo.html">TRBurstMetaInfo</a> const &amp;info)</td></tr>
<tr class="memdesc:a67e12c5814534c930a6aa7073d3dfe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish meta-information about a burst.  <a href="#a67e12c5814534c930a6aa7073d3dfe3b">More...</a><br /></td></tr>
<tr class="separator:a67e12c5814534c930a6aa7073d3dfe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493f33cc9b0f3f42d09f2caaa53ead10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a493f33cc9b0f3f42d09f2caaa53ead10">maybeSleepForTesting</a> ()</td></tr>
<tr class="memdesc:a493f33cc9b0f3f42d09f2caaa53ead10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibly sleep for testing if enabled.  <a href="#a493f33cc9b0f3f42d09f2caaa53ead10">More...</a><br /></td></tr>
<tr class="separator:a493f33cc9b0f3f42d09f2caaa53ead10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d97099c26ba2b2eeace73a673e666ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a6d97099c26ba2b2eeace73a673e666ce">isArmed</a> ()</td></tr>
<tr class="memdesc:a6d97099c26ba2b2eeace73a673e666ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if acquisition is currently armed.  <a href="#a6d97099c26ba2b2eeace73a673e666ce">More...</a><br /></td></tr>
<tr class="separator:a6d97099c26ba2b2eeace73a673e666ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb3f05b8aa96dc615da10fccf41cc09"><td class="memItemLeft" align="right" valign="top">virtual asynStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a0fb3f05b8aa96dc615da10fccf41cc09">writeInt32</a> (asynUser *pasynUser, epicsInt32 value)</td></tr>
<tr class="memdesc:a0fb3f05b8aa96dc615da10fccf41cc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overridden asyn parameter write handler.  <a href="#a0fb3f05b8aa96dc615da10fccf41cc09">More...</a><br /></td></tr>
<tr class="separator:a0fb3f05b8aa96dc615da10fccf41cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc515564a10ad7e117b669d30a471525"><td class="memItemLeft" align="right" valign="top">virtual asynStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#acc515564a10ad7e117b669d30a471525">writeFloat64</a> (asynUser *pasynUser, epicsFloat64 value)</td></tr>
<tr class="memdesc:acc515564a10ad7e117b669d30a471525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overridden asyn parameter write handler.  <a href="#acc515564a10ad7e117b669d30a471525">More...</a><br /></td></tr>
<tr class="separator:acc515564a10ad7e117b669d30a471525"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8ca35e2067f89c2aa4e6f07e9d18aea5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTRChannelsDriver.html">TRChannelsDriver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a8ca35e2067f89c2aa4e6f07e9d18aea5">createChannelsDriver</a> ()</td></tr>
<tr class="memdesc:a8ca35e2067f89c2aa4e6f07e9d18aea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the channels driver.  <a href="#a8ca35e2067f89c2aa4e6f07e9d18aea5">More...</a><br /></td></tr>
<tr class="separator:a8ca35e2067f89c2aa4e6f07e9d18aea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdca3e00a0ab8355d42851fca6d3a4c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#abdca3e00a0ab8355d42851fca6d3a4c4">requestedSampleRateChanged</a> ()</td></tr>
<tr class="memdesc:abdca3e00a0ab8355d42851fca6d3a4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports that the requested sample rate has changed.  <a href="#abdca3e00a0ab8355d42851fca6d3a4c4">More...</a><br /></td></tr>
<tr class="separator:abdca3e00a0ab8355d42851fca6d3a4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab373077c14ddd263a7bc6dd11cf6e785"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#ab373077c14ddd263a7bc6dd11cf6e785">waitForPreconditions</a> ()</td></tr>
<tr class="memdesc:ab373077c14ddd263a7bc6dd11cf6e785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for preconditions for arming to be satisifed.  <a href="#ab373077c14ddd263a7bc6dd11cf6e785">More...</a><br /></td></tr>
<tr class="separator:ab373077c14ddd263a7bc6dd11cf6e785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ddb213060a17f0c9c66b9a2d562134"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">checkSettings</a> (<a class="el" href="classTRArmInfo.html">TRArmInfo</a> &amp;arm_info)=0</td></tr>
<tr class="memdesc:ab1ddb213060a17f0c9c66b9a2d562134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check preconditions for arming and report the sample freq rate for display.  <a href="#ab1ddb213060a17f0c9c66b9a2d562134">More...</a><br /></td></tr>
<tr class="separator:ab1ddb213060a17f0c9c66b9a2d562134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070e41e3e124ce83bc44a5214814f2aa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a070e41e3e124ce83bc44a5214814f2aa">startAcquisition</a> (bool overflow)=0</td></tr>
<tr class="memdesc:a070e41e3e124ce83bc44a5214814f2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the hardware to start acquisition.  <a href="#a070e41e3e124ce83bc44a5214814f2aa">More...</a><br /></td></tr>
<tr class="separator:a070e41e3e124ce83bc44a5214814f2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eb4c8f4c81286393e2c48c6ee93074"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a89eb4c8f4c81286393e2c48c6ee93074">readBurst</a> ()</td></tr>
<tr class="memdesc:a89eb4c8f4c81286393e2c48c6ee93074"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called in a loop to wait for and read a burst of data.  <a href="#a89eb4c8f4c81286393e2c48c6ee93074">More...</a><br /></td></tr>
<tr class="separator:a89eb4c8f4c81286393e2c48c6ee93074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04f2ac00edeb64b1cb3ac7b383f47a5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#ab04f2ac00edeb64b1cb3ac7b383f47a5">checkOverflow</a> (bool *had_overflow, int *num_buffer_bursts)</td></tr>
<tr class="memdesc:ab04f2ac00edeb64b1cb3ac7b383f47a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there has been a buffer overlow.  <a href="#ab04f2ac00edeb64b1cb3ac7b383f47a5">More...</a><br /></td></tr>
<tr class="separator:ab04f2ac00edeb64b1cb3ac7b383f47a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad622b8da2b13c745691b14fb9a1c6052"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#ad622b8da2b13c745691b14fb9a1c6052">processBurstData</a> ()</td></tr>
<tr class="memdesc:ad622b8da2b13c745691b14fb9a1c6052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the read that has just been read by readBurst.  <a href="#ad622b8da2b13c745691b14fb9a1c6052">More...</a><br /></td></tr>
<tr class="separator:ad622b8da2b13c745691b14fb9a1c6052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3dd294a865cd768f3683f885fd849e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a7b3dd294a865cd768f3683f885fd849e">interruptReading</a> ()</td></tr>
<tr class="memdesc:a7b3dd294a865cd768f3683f885fd849e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt reading of data.  <a href="#a7b3dd294a865cd768f3683f885fd849e">More...</a><br /></td></tr>
<tr class="separator:a7b3dd294a865cd768f3683f885fd849e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5692c5734f8b00330a98d0c4f5bf17db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a5692c5734f8b00330a98d0c4f5bf17db">stopAcquisition</a> ()=0</td></tr>
<tr class="memdesc:a5692c5734f8b00330a98d0c4f5bf17db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the hardware to stop acquisition.  <a href="#a5692c5734f8b00330a98d0c4f5bf17db">More...</a><br /></td></tr>
<tr class="separator:a5692c5734f8b00330a98d0c4f5bf17db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052f3a5c9fdf6d025b486315a4061440"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRBaseDriver.html#a052f3a5c9fdf6d025b486315a4061440">onDisarmed</a> ()</td></tr>
<tr class="memdesc:a052f3a5c9fdf6d025b486315a4061440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when <a class="el" href="classTRBaseDriver.html#a6d97099c26ba2b2eeace73a673e666ce">isArmed()</a> changes from true to false.  <a href="#a052f3a5c9fdf6d025b486315a4061440">More...</a><br /></td></tr>
<tr class="separator:a052f3a5c9fdf6d025b486315a4061440"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a92d6d685ad6ab884f0e6e910f545312b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a92d6d685ad6ab884f0e6e910f545312b"></a>
template&lt;typename , typename &gt; </td></tr>
<tr class="memitem:a92d6d685ad6ab884f0e6e910f545312b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TRConfigParam</b></td></tr>
<tr class="separator:a92d6d685ad6ab884f0e6e910f545312b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243f81fc0861482cd6ff4943cc7cab6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a243f81fc0861482cd6ff4943cc7cab6d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TRChannelsDriver</b></td></tr>
<tr class="separator:a243f81fc0861482cd6ff4943cc7cab6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd360cfe77d12ca533d3fe56bb9d42ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd360cfe77d12ca533d3fe56bb9d42ab"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TRChannelDataSubmit</b></td></tr>
<tr class="separator:afd360cfe77d12ca533d3fe56bb9d42ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Central class of the Transient Recorder framework for transient recorders (digitizers). </p>
<p>Digitizer drivers use this class by inheriting it, constructing it with the appropriate parameters and implementing various virtual functions.</p>
<p>The major features provided by this class are:</p><ul>
<li>Management of arming and disarming.</li>
<li>Generic implementation of a burst reading/processing loop (optional).</li>
<li>Management of configuration parameters with automatic capture of a configuration snapshot at the start of arming.</li>
<li>Abstraction of submitting data into the AreaDetector system.</li>
<li>Infrastructure for configuration of the sample rate and implementation of the time array (for graphs). </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a712657c4e9bda0315f0b44473690a2db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TRBaseDriver::TRBaseDriver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTRBaseConfig.html">TRBaseConfig</a> const &amp;&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="classTRBaseDriver.html" title="Central class of the Transient Recorder framework for transient recorders (digitizers). ">TRBaseDriver</a>, to be used from constructors of derived classes. </p>
<p>The function <a class="el" href="classTRBaseDriver.html#a2b5578f3d5e8961ab24cb85aa12762df">completeInit</a> MUST be called just after the entire object is constructed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>Parameters for construction as a struct. See <a class="el" href="classTRChannelDataSubmit.html" title="Class for submitting burst data. ">TRChannelDataSubmit</a> for an example of how to initialize the parameters in an expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1ffec79dcf8c5fb8ba5ffd3ce87c121f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename EffectiveValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TRBaseDriver::initConfigParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTRConfigParam.html">TRConfigParam</a>&lt; ValueType, EffectiveValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>base_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EffectiveValueType&#160;</td>
          <td class="paramname"><em>invalid_value</em> = <code>EffectiveValueType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a configuration parameter. </p>
<p>This should be called in the constructor of derived classes for all configuration parameters (ConfigParam) defined by the driver, excluding internal configuration parameters (those should be initialized using <a class="el" href="classTRBaseDriver.html#a017dc1a597090971fdcc6fa5e466b2b5">initInternalParam</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The configuration parameter to be initialized. </td></tr>
    <tr><td class="paramname">base_name</td><td>The base name of the configuration parameter. The prefixes DESIRED_ and EFFECTIVE_ will be added to form the asyn parameter names. </td></tr>
    <tr><td class="paramname">invalid_value</td><td>The invalid value for the effective-value parameter, which is its value when the device is not armed or the parameter is irrelevant due to other configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a017dc1a597090971fdcc6fa5e466b2b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename EffectiveValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TRBaseDriver::initInternalParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTRConfigParam.html">TRConfigParam</a>&lt; ValueType, EffectiveValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>base_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EffectiveValueType&#160;</td>
          <td class="paramname"><em>invalid_value</em> = <code>EffectiveValueType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an internal configration parameter. </p>
<p>An internal parameter differs from a regular configuration parameter in that its desired value is not set though the external (EPICS) interface but by the driver, using <a class="el" href="classTRConfigParam.html#a41e957cb181190f738518dfeedf58db4" title="Set the desired value of an internal parameter. ">TRConfigParam::setDesired</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The configuration parameter to be initialized. </td></tr>
    <tr><td class="paramname">base_name</td><td>The base name of the configuration parameter. The prefixes DESIRED_ and EFFECTIVE_ will be added to form the asyn parameter names. </td></tr>
    <tr><td class="paramname">invalid_value</td><td>The invalid value for the effective-value parameter, which is its value when the device is not armed or the parameter is irrelevant due to other configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b5578f3d5e8961ab24cb85aa12762df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TRBaseDriver::completeInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete initialization of the class. </p>
<p>This MUST be called immediately after the entire object is constructed including derived objects. It performs initialization which could not be performed in the constructor.</p>
<p>Notably, it creates the channels driver, which involves calling the virtual function createChannelsDriver. </p>

</div>
</div>
<a class="anchor" id="ad0f5747bad2e87db7148f2e52a132523"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTRChannelsDriver.html">TRChannelsDriver</a>&amp; TRBaseDriver::getChannelsDriver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the channels driver. </p>
<p>This MUST NOT be called before <a class="el" href="classTRBaseDriver.html#a2b5578f3d5e8961ab24cb85aa12762df">completeInit</a> is completed, as the channels driver is constructed in completeInit.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the channels driver. </dd></dl>

</div>
</div>
<a class="anchor" id="aafad865f171e12b63b97e642ad59aae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TRBaseDriver::setDigitizerName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the name of the digitizer, which will appear as the value of the "name" PV. </p>
<p>The default name is the asyn port name.</p>
<p>This function MUST be called with the port locked, except if called before EPICS could interact with the asyn port such as from the driver's constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Digitizer name (pointer is not used after return). Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94f98559d9a9208e18c7438bec648f6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TRBaseDriver::getRequestedSampleRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the requested sample rate. </p>
<p>Note that it is allowed for the driver to use special sample rate values such as negative ones, e.g. to use an external clock source. But otherwise the value should be in Hz.</p>
<p>This function MUST be called with the port locked.</p>
<dl class="section return"><dt>Returns</dt><dd>The requested sample rate. </dd></dl>

</div>
</div>
<a class="anchor" id="a43f2a60d33275dc1ca9d9bfd03edc9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TRBaseDriver::setAchievableSampleRate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the achievable sample rate corresponding to the requested sample rate. </p>
<p>As in <a class="el" href="classTRBaseDriver.html#a94f98559d9a9208e18c7438bec648f6a">getRequestedSampleRate</a>, it is allowed for the driver to use special sample rate values. But otherwise the value should be in Hz.</p>
<p>This function MUST be called with the port locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The achievable sample rate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e63889bd84f60be719d15dfd405ab4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int TRBaseDriver::getNumBurstsSnapshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the snapshot value of the number of bursts to capture. </p>
<p>This will be either positive (for a specific number of bursts) or 0 (for an unlimited number of bursts).</p>
<p>This function is meant to be used by drivers which do not use the framework's read loop so that they can initiate disarming when the requested number of bursts have been captured.</p>
<p>See <a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">checkSettings</a> for limitations regarding reading snapshot values.</p>
<dl class="section return"><dt>Returns</dt><dd>The snapshot number of bursts. </dd></dl>

</div>
</div>
<a class="anchor" id="ad64d62a21e6555851c8c85b9942579b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int TRBaseDriver::getNumPostSamplesSnapshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the snapshot value of the number of post-trigger samples per event. </p>
<p>This will be non-negative. If the driver does not declare support for pre-trigger samples (<a class="el" href="classTRBaseConfig.html#a875482f9c94f69f764e489eced30e451">TRBaseConfig::supports_pre_samples</a> is false), then this is also guaranteed to be positive. Otherwise, see <a class="el" href="classTRBaseDriver.html#a43bd33f4704b42fe5c6255f86e563db8">getNumPrePostSamplesSnapshot</a> for additional guarantees.</p>
<p>See <a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">checkSettings</a> for limitations regarding reading snapshot values.</p>
<dl class="section return"><dt>Returns</dt><dd>The snapshot number of post-samples. </dd></dl>

</div>
</div>
<a class="anchor" id="a43bd33f4704b42fe5c6255f86e563db8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int TRBaseDriver::getNumPrePostSamplesSnapshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the snapshot value for the total number of samples per event (counting pre-trigger and post-trigger samples). </p>
<p>This will always be positive and will be greater than or equal to <a class="el" href="classTRBaseDriver.html#ad64d62a21e6555851c8c85b9942579b9">getNumPostSamplesSnapshot</a>. Equality means that no pre-trigger samples are desired.</p>
<p>See <a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">checkSettings</a> for limitations regarding reading snapshot values.</p>
<dl class="section return"><dt>Returns</dt><dd>The snapshot number of pre-post-samples. </dd></dl>

</div>
</div>
<a class="anchor" id="a50b6399f6598270f2f1ccf899f9652cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double TRBaseDriver::getRequestedSampleRateSnapshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the snapshot value of the requested sample rate. </p>
<p>This will be the value of <a class="el" href="classTRBaseDriver.html#a94f98559d9a9208e18c7438bec648f6a">getRequestedSampleRate</a> at the time the snapshot was made.</p>
<p>See <a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">checkSettings</a> for limitations regarding reading snapshot values.</p>
<dl class="section return"><dt>Returns</dt><dd>The snapshot requested sample rate. </dd></dl>

</div>
</div>
<a class="anchor" id="aa82a97ddd260bf97b0ccfba5b620b4ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double TRBaseDriver::getAchievableSampleRateSnapshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the snapshot value of the achievable sample rate. </p>
<p>This will be the last value set using <a class="el" href="classTRBaseDriver.html#a43f2a60d33275dc1ca9d9bfd03edc9b5">setAchievableSampleRate</a> at the time the snapshot was made.</p>
<p>See <a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">checkSettings</a> for limitations regarding reading snapshot values.</p>
<dl class="section return"><dt>Returns</dt><dd>The snapshot achievable sample rate. </dd></dl>

</div>
</div>
<a class="anchor" id="ab26e54e4756b4255d88b2e894967fe02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TRBaseDriver::requestDisarmingFromDriver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request disarming of acquisition. </p>
<p>This allows the driver itself to initiate disarming as if a disarm request was received. If acquisition is currently disarmed, nothing will be done.</p>
<p>This function MUST be called with the port lock held.</p>
<p>This function may sychronously call the <a class="el" href="classTRBaseDriver.html#a7b3dd294a865cd768f3683f885fd849e">interruptReading</a> driver function. That must be considered when the driver has overridden interruptReading (that should be the case in any driver that uses the framework's read loop).</p>
<p>There are two use cases for this:</p><ul>
<li>When the driver does not use the framework's read loop (leaves default implementations of <a class="el" href="classTRBaseDriver.html#a89eb4c8f4c81286393e2c48c6ee93074">readBurst</a>, <a class="el" href="classTRBaseDriver.html#ad622b8da2b13c745691b14fb9a1c6052">processBurstData</a>, <a class="el" href="classTRBaseDriver.html#ab04f2ac00edeb64b1cb3ac7b383f47a5">checkOverflow</a> and <a class="el" href="classTRBaseDriver.html#a7b3dd294a865cd768f3683f885fd849e">interruptReading</a>), in order to indicate to the framework that the requested number of bursts have been read.</li>
<li>To indicate to the framework that a driver-specific condition to automatically disarm has been detected (whether or not the driver uses the framework's read loop).</li>
</ul>
<p>If the driver uses the read loop and does not support any driver-specific conditions to automatically disarm, there is no reason to call this; the framework will itself automatically disarm after the desired number of bursts have been read. </p>

</div>
</div>
<a class="anchor" id="a67e12c5814534c930a6aa7073d3dfe3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TRBaseDriver::publishBurstMetaInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTRBurstMetaInfo.html">TRBurstMetaInfo</a> const &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish meta-information about a burst. </p>
<p>This function should be called after data for a burst has been submitted (using <a class="el" href="classTRChannelDataSubmit.html" title="Class for submitting burst data. ">TRChannelDataSubmit</a>). If the driver uses the framework's read loop, this should be from the function <a class="el" href="classTRBaseDriver.html#ad622b8da2b13c745691b14fb9a1c6052">processBurstData</a>.</p>
<p>The driver should call <code>asynPortDriver::updateTimeStamp</code> on this driver (not the channels driver) for each burst before calling this function. This is because the framework will report the time of the last burst based on the current timestamp in the driver. It is expected that most drivers will use the timestamp obtained by updateTimeStamp as the timestamp of channel data arrays of all channels involved in the burst (the epics_ts argument to <a class="el" href="classTRChannelDataSubmit.html#a81b6626d8588bebabe9f4b28b8ca6029" title="Submit the array to AreaDetector. ">TRChannelDataSubmit::submit</a>).</p>
<p>This function MUST be called with the port unlocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Meta-information about the burst. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a493f33cc9b0f3f42d09f2caaa53ead10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TRBaseDriver::maybeSleepForTesting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possibly sleep for testing if enabled. </p>
<p>The framework implements a feature to optionally sleep after reading a burst, for testing purposes, especially testing of buffer overflow handling .</p>
<p>If the driver uses the framework's read loop, this function is automatically called after (successful) <a class="el" href="classTRBaseDriver.html#ad622b8da2b13c745691b14fb9a1c6052">processBurstData</a>. Otherwise, the driver may call this at the appropriate time to gain the capability to sleep after reading a burst (or generally wherever it wishes).</p>
<p>This function MUST be called with the port unlocked. </p>

</div>
</div>
<a class="anchor" id="a6d97099c26ba2b2eeace73a673e666ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TRBaseDriver::isArmed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if acquisition is currently armed. </p>
<p>For the purposes of this function, acquisition becomes armed when waitForPreconditions is started and becomes not armed after stopAcquisition returns, or if there was an error before startAcquisition then immediately after the error.</p>
<p>This function MUST be called with the port locked.</p>
<dl class="section return"><dt>Returns</dt><dd>True if disarmed, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ca35e2067f89c2aa4e6f07e9d18aea5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTRChannelsDriver.html">TRChannelsDriver</a>* TRBaseDriver::createChannelsDriver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the channels driver. </p>
<p>This function allows the driver to use its own derived class of <a class="el" href="classTRChannelsDriver.html" title="An asynNDArrayDriver-based class though which burst data is submitted into the AreaDetector framework...">TRChannelsDriver</a> for the channels port.</p>
<p>If this function is overridden, it MUST create an instance (using new) of a <a class="el" href="classTRChannelsDriver.html" title="An asynNDArrayDriver-based class though which burst data is submitted into the AreaDetector framework...">TRChannelsDriver</a> derived class. If the driver does not override this function, the default implementation will create an instance of <a class="el" href="classTRChannelsDriver.html" title="An asynNDArrayDriver-based class though which burst data is submitted into the AreaDetector framework...">TRChannelsDriver</a>.</p>
<p>One reason the driver may want to use a custom <a class="el" href="classTRChannelsDriver.html" title="An asynNDArrayDriver-based class though which burst data is submitted into the AreaDetector framework...">TRChannelsDriver</a> derived class is to add asyn parameters to it. However, note that this is only needed when the parameter needs to be per-channel, otherwise the parameter would be better suited to the main class (derived class of <a class="el" href="classTRBaseDriver.html" title="Central class of the Transient Recorder framework for transient recorders (digitizers). ">TRBaseDriver</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>The new channels driver, allocated using new. </dd></dl>

</div>
</div>
<a class="anchor" id="abdca3e00a0ab8355d42851fca6d3a4c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TRBaseDriver::requestedSampleRateChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports that the requested sample rate has changed. </p>
<p>The driver should recalculate the achievable sample rate (<a class="el" href="classTRBaseDriver.html#a43f2a60d33275dc1ca9d9bfd03edc9b5">setAchievableSampleRate</a>) based on the requested sample rate (<a class="el" href="classTRBaseDriver.html#a94f98559d9a9208e18c7438bec648f6a">getRequestedSampleRate</a>). That can be done either synchronously in this function (if the calculation is not demanding) or asynchronously. In the latter case, it is important that <a class="el" href="classTRBaseDriver.html#ab373077c14ddd263a7bc6dd11cf6e785">waitForPreconditions</a> waits until any ongoing clock calculation is completed.</p>
<p>This is called with the port locked and it MUST NOT unlock it at any point.</p>
<p>The default implementation calls getRequestedSampleRate then calls setAchievableSampleRate with that value. Be careful because this is probably not currect for most drivers, as the hardware usually allows only a discrete set of sample rates. </p>

</div>
</div>
<a class="anchor" id="ab373077c14ddd263a7bc6dd11cf6e785"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TRBaseDriver::waitForPreconditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for preconditions for arming to be satisifed. </p>
<p>This is called at the very beginning of arming. If this function returns false, arming will not proceed and an error will be reported. In that case the framework will wait until disarming is requested and only then allow another arming attempt.</p>
<p>This function is called with the port locked and MUST return with the port locked. It MAY internally unlock and re-lock the port (actually it must do that while waiting for anything).</p>
<p>In case of successful return, the framework will make snapshots of desired configuration parameters while the port is still locked. Normally arming will then proceed with <a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">checkSettings</a>. However, there is no guarantee that a successful waitForPreconditions call will be followed by checkSettings; arming may be aborted without notice at this stage.</p>
<p>The default implementation only returns true.</p>
<dl class="section return"><dt>Returns</dt><dd>True on success (port locked, proceed with arming), false on error (port not locked, abort arming). </dd></dl>

</div>
</div>
<a class="anchor" id="ab1ddb213060a17f0c9c66b9a2d562134"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TRBaseDriver::checkSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTRArmInfo.html">TRArmInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>arm_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check preconditions for arming and report the sample freq rate for display. </p>
<p>This is called just after a successful <a class="el" href="classTRBaseDriver.html#ab373077c14ddd263a7bc6dd11cf6e785">waitForPreconditions</a>.</p>
<p>If this function returns false, arming will not proceed and an error will be reported. In that case the framework will wait until disarming is requested and only then allow another arming attempt.</p>
<p>If this function returns true, it must fill in arm_info as appropriate. Note that setting <a class="el" href="classTRArmInfo.html#ae59f205cc9afac4649a093111817775f" title="The driver MUST set this to the display sample rate. ">TRArmInfo::rate_for_display</a> is mandatory in this case.</p>
<p>This is called with the port locked and it MUST NOT unlock it at any point.</p>
<p>There is no guarantee that a successful checkSettings will be followed by <a class="el" href="classTRBaseDriver.html#a070e41e3e124ce83bc44a5214814f2aa">startAcquisition</a>, arming may be aborted without notice at this stage.</p>
<p>Starting with this function, the driver is allowed to read the parameter snapshot values using <a class="el" href="classTRConfigParam.html#a27361deb50197a160bc00f662502e51b" title="Return the current snapshot value of the parameter. ">TRConfigParam::getSnapshot</a> as well as snapshot values provided by the framework (get*Snapshot functions). The snapshot values were captured just after waitForPreconditions returned successfully. Snapshot values may be read and are guaranteed to not change until the driver returns from stopAcquisition.</p>
<p>NOTE: Snapshot values MUST NOT be read before checkSettings is called or after <a class="el" href="classTRBaseDriver.html#a5692c5734f8b00330a98d0c4f5bf17db">stopAcquisition</a> returns (until the next checkSettings call).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arm_info</td><td>The driver must set the relevant variables of this class if it returns true. Note that some of the variables are mandatory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success (proceed with arming), false on error (abort arming). </dd></dl>

</div>
</div>
<a class="anchor" id="a070e41e3e124ce83bc44a5214814f2aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TRBaseDriver::startAcquisition </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overflow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure the hardware to start acquisition. </p>
<p>This can be called in two scenarios. The normal scenario is just after <a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">checkSettings</a> returned true (overflow==false). The other scenario is as part of recovery from buffer overflow (overflow==true).</p>
<p>This function should return false in case of unexpected errors. In that case an error will be reported, the framework will wait until disarming is requested, and only then call <a class="el" href="classTRBaseDriver.html#a5692c5734f8b00330a98d0c4f5bf17db">stopAcquisition</a> and allow another arming attempt.</p>
<p>This is called with the port unlocked and MUST return unlocked. It MAY internally lock and unlock the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overflow</td><td>Whether this the initial call during for arming (overflow==false) or a subsequent call after a buffer overflow (overflow==true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success (proceed with the read loop), false on error (abort arming). </dd></dl>

</div>
</div>
<a class="anchor" id="a89eb4c8f4c81286393e2c48c6ee93074"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TRBaseDriver::readBurst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called in a loop to wait for and read a burst of data. </p>
<p>If the driver does not wish to use the framework's implementation of the read loop:</p>
<ul>
<li>It MUST NOT override <a class="el" href="classTRBaseDriver.html#a89eb4c8f4c81286393e2c48c6ee93074">readBurst</a> and <a class="el" href="classTRBaseDriver.html#a7b3dd294a865cd768f3683f885fd849e">interruptReading</a> and should not override <a class="el" href="classTRBaseDriver.html#ab04f2ac00edeb64b1cb3ac7b383f47a5">checkOverflow</a> and <a class="el" href="classTRBaseDriver.html#ad622b8da2b13c745691b14fb9a1c6052">processBurstData</a> (the latter two would never be called then).</li>
<li>It should submit data (using <a class="el" href="classTRChannelDataSubmit.html" title="Class for submitting burst data. ">TRChannelDataSubmit</a>) from its own threads.</li>
</ul>
<p>This function should read one burst of data from the hardware buffers. Processing and submitting of data should be done in <a class="el" href="classTRBaseDriver.html#ad622b8da2b13c745691b14fb9a1c6052">processBurstData</a> which will normally follow <a class="el" href="classTRBaseDriver.html#a89eb4c8f4c81286393e2c48c6ee93074">readBurst</a> (but may not in case of disarming).</p>
<p>This function should return false in case of unexpected errors. In that case an error will be reported, the framework will wait until disarming is requested, and only then call <a class="el" href="classTRBaseDriver.html#a5692c5734f8b00330a98d0c4f5bf17db">stopAcquisition</a> and allow another arming attempt.</p>
<p>This is called with the port unlocked and MUST return unlocked. It MAY internally lock and unlock the port.</p>
<dl class="section return"><dt>Returns</dt><dd>True on success of if aborted due to <a class="el" href="classTRBaseDriver.html#a7b3dd294a865cd768f3683f885fd849e">interruptReading</a>, false on error (stop reading). </dd></dl>

</div>
</div>
<a class="anchor" id="ab04f2ac00edeb64b1cb3ac7b383f47a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TRBaseDriver::checkOverflow </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>had_overflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>num_buffer_bursts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if there has been a buffer overlow. </p>
<p>If the driver does not wish to use the framework's implementation of the read loop, it should not override this function (it would not be called).</p>
<p>This is called after every successful <a class="el" href="classTRBaseDriver.html#a89eb4c8f4c81286393e2c48c6ee93074">readBurst</a> when a buffer overflow has not yet occurred. It should set *had_overflow to whether an overflow has occurred. If it sets *had_overflow to true, it should also set *num_buffer_bursts to the remaining number of bursts that can be read before restarting PLUS ONE (i.e. including the burst just read). Typically, *num_buffer_bursts would be set to the number of bursts which fit into the hardware buffer. But be careful because hardware may claim to have some power-of-two buffer size but really have one fewer usable capacity.</p>
<p>This function should return false in case of unexpected errors. In that case it is not necessary to set *had_overflow or *num_buffer_bursts, an error will be reported, the framework will wait until disarming is requested, and only then call <a class="el" href="classTRBaseDriver.html#a5692c5734f8b00330a98d0c4f5bf17db">stopAcquisition</a> and allow another arming attempt.</p>
<p>If an overflow is detected, the driver may also perform any actions necessary to allow reading of the remaining data to proceed without problems.</p>
<p>This is called with the port unlocked and MUST return unlocked. It MAY internally lock and unlock the port.</p>
<p>The default implementation sets *had_overflow to false and returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">had_overflow</td><td>On success, this should be set to whether a buffer overflow has occurred. </td></tr>
    <tr><td class="paramname">num_buffer_bursts</td><td>On success and if a buffer overflow has occurred, this MUST be set to the remaining number of bursts that can be read PLUS ONE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (stop reading). </dd></dl>

</div>
</div>
<a class="anchor" id="ad622b8da2b13c745691b14fb9a1c6052"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TRBaseDriver::processBurstData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process the read that has just been read by readBurst. </p>
<p>If the driver does not wish to use the framework's implementation of the read loop, it should not override this function (it would not be called).</p>
<p>This is normally called after each successful <a class="el" href="classTRBaseDriver.html#a89eb4c8f4c81286393e2c48c6ee93074">readBurst</a> call (but may not be in exceptional cases like disarming or errors). From within this function, the driver should submit burst data using <a class="el" href="classTRChannelDataSubmit.html" title="Class for submitting burst data. ">TRChannelDataSubmit</a> objects and (preferably after that) call <a class="el" href="classTRBaseDriver.html#a67e12c5814534c930a6aa7073d3dfe3b">publishBurstMetaInfo</a>.</p>
<p>This function should return false in case of unexpected errors. In that case an error will be reported, the framework will wait until disarming is requested, and only then call <a class="el" href="classTRBaseDriver.html#a5692c5734f8b00330a98d0c4f5bf17db">stopAcquisition</a> and allow another arming attempt.</p>
<p>This is called with the port unlocked and MUST return unlocked. It MAY internally lock and unlock the port.</p>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on error (stop reading). </dd></dl>

</div>
</div>
<a class="anchor" id="a7b3dd294a865cd768f3683f885fd849e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TRBaseDriver::interruptReading </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt reading of data. </p>
<p>If the driver does not wish to use the framework's implementation of the read loop, MUST NOT override this function.</p>
<p>This will only be called while the read thread is in the core of the read loop, that is after a successful <a class="el" href="classTRBaseDriver.html#a070e41e3e124ce83bc44a5214814f2aa">startAcquisition</a> but before <a class="el" href="classTRBaseDriver.html#a5692c5734f8b00330a98d0c4f5bf17db">stopAcquisition</a>, and also only in between two startAcquisition in case of buffer overflows. It will also be called no more than once in the entire arming sequence.</p>
<p>Calling this must ensure that any ongoing or future <a class="el" href="classTRBaseDriver.html#a89eb4c8f4c81286393e2c48c6ee93074">readBurst</a> call returns as soon as possible and that any future readBurst call returns immediately. Note that readBurst must not return an error (false) due to this interruption; readBurst does not need to report to the caller whether it returned due to interruption or because a burst was read.</p>
<p>This is called with the port locked and it MUST NOT unlock it at any point. It MUST NOT block. If synchronous actions are needed to ensure that reading is interrupted reliably, they MUST be done on another thread. </p>

</div>
</div>
<a class="anchor" id="a5692c5734f8b00330a98d0c4f5bf17db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TRBaseDriver::stopAcquisition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure the hardware to stop acquisition. </p>
<p>This is called after a call to <a class="el" href="classTRBaseDriver.html#a070e41e3e124ce83bc44a5214814f2aa">startAcquisition</a>, and is to be understood as the reverse of that. It is called after any <a class="el" href="classTRBaseDriver.html#a89eb4c8f4c81286393e2c48c6ee93074">readBurst</a>, <a class="el" href="classTRBaseDriver.html#ab04f2ac00edeb64b1cb3ac7b383f47a5">checkOverflow</a> or <a class="el" href="classTRBaseDriver.html#ad622b8da2b13c745691b14fb9a1c6052">processBurstData</a> calls have returned.</p>
<p>After this returns, the hardware will be considered disarmed and a new arming may later start, beginning with <a class="el" href="classTRBaseDriver.html#ab373077c14ddd263a7bc6dd11cf6e785">waitForPreconditions</a>. There is no way to return an error here as the framework could not reasonably react to an error.</p>
<p>This is called with the port unlocked and MUST return unlocked. It MAY internally lock and unlock the port. </p>

</div>
</div>
<a class="anchor" id="a052f3a5c9fdf6d025b486315a4061440"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TRBaseDriver::onDisarmed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when <a class="el" href="classTRBaseDriver.html#a6d97099c26ba2b2eeace73a673e666ce">isArmed()</a> changes from true to false. </p>
<p>This is called with the port locked and it MUST NOT unlock it.</p>
<p>This was added to support a design where changing a desired configuration parameter value should actually apply the change immediately unless the digitizer is armed, but if the value is changed while armed it should still be applied automatically when the digitizer is disarmed. To implement this correctly you should:</p><ul>
<li>Override the write function corresponding to the type of the type of the parameter (<a class="el" href="classTRBaseDriver.html#a0fb3f05b8aa96dc615da10fccf41cc09">writeInt32</a> or <a class="el" href="classTRBaseDriver.html#acc515564a10ad7e117b669d30a471525">writeFloat64</a>). There, before checking whether the parameter is owned by one of the base classes, check if the parameter index is equal to <a class="el" href="classTRConfigParam.html#a40201e113d8a9041fcbe8cd8ce4bf20e">TRConfigParam::desiredParamIndex()</a>. If it is equal then...</li>
<li>Call <a class="el" href="classTRBaseDriver.html#a6d97099c26ba2b2eeace73a673e666ce">isArmed()</a> and if it returned false, apply the configuration to hardware. You should use the value parameter of the function since <a class="el" href="classTRConfigParam.html#adf9e9d34c7682824cb8b67fe1854c738">TRConfigParam::getDesired</a> was not updated yet at this point. You should still call and return the result of the base class write function regardless of isArmed.</li>
<li>Implement onDisarmed and in that function ensure that the value returned by <a class="el" href="classTRConfigParam.html#adf9e9d34c7682824cb8b67fe1854c738">TRConfigParam::getDesired</a> is applied to the hardware. You can use a dirty flag to avoid having to access the hardware redundantly.</li>
</ul>
<p>Do not instead use <a class="el" href="classTRBaseDriver.html#a5692c5734f8b00330a98d0c4f5bf17db">stopAcquisition</a> for this or similar purposes because of possible race conditions and since stopAcquisition may not be called in case of an early error.</p>
<p>The default implementation does nothing. </p>

</div>
</div>
<a class="anchor" id="a0fb3f05b8aa96dc615da10fccf41cc09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asynStatus TRBaseDriver::writeInt32 </td>
          <td>(</td>
          <td class="paramtype">asynUser *&#160;</td>
          <td class="paramname"><em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsInt32&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overridden asyn parameter write handler. </p>
<p>It is important that derived classes which override this function delegate to the base class method when the parameter is not from the derived class, including when the parameter belongs to a <a class="el" href="classTRConfigParam.html" title="Transient Recorder configuration parameter. ">TRConfigParam</a> defined by the derived class.</p>
<p>Care is needed because a comparison of the parameter index to the index of the first own parameter of the derived class may not yield the expected result. If such a check is used, then the dervived class must initialize all its <a class="el" href="classTRConfigParam.html" title="Transient Recorder configuration parameter. ">TRConfigParam</a> before its normal asyn parameters. This way, the asyn parameters belonging to <a class="el" href="classTRConfigParam.html" title="Transient Recorder configuration parameter. ">TRConfigParam</a> will receive lower indices than normal asyn parameters of the derived class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pasynUser</td><td>Asyn user object. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation result. </dd></dl>

</div>
</div>
<a class="anchor" id="acc515564a10ad7e117b669d30a471525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asynStatus TRBaseDriver::writeFloat64 </td>
          <td>(</td>
          <td class="paramtype">asynUser *&#160;</td>
          <td class="paramname"><em>pasynUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epicsFloat64&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overridden asyn parameter write handler. </p>
<p>Refer to the documentation of <a class="el" href="classTRBaseDriver.html#a0fb3f05b8aa96dc615da10fccf41cc09">writeInt32</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pasynUser</td><td>Asyn user object. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation result. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="TRBaseDriver_8h_source.html">TRBaseDriver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
