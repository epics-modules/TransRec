<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Transient Recorder Framework: SIS3302 Digitizer Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Transient Recorder Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">SIS3302 Digitizer Driver </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page describes SIS3302 digitzer driver based on the Transient Recorder Framework.</p>
<h2>Platforms</h2>
<p>The driver has been developed to work on RTEMS and on MVME3100 and MVME6100 boards.</p>
<h2>Dependencies</h2>
<ul>
<li>TRCore and its dependencies (Asyn, ADCore).</li>
<li>SLAC's drvRTEMSDmaSup.</li>
</ul>
<p>See the configure/RELEASE.example file. You need to create the configure/RELEASE file on your own.</p>
<p>Note that you may have to create a proper EPICS build environment for drvRTEMSDmaSup which installs headers and libraries.</p>
<h2>Initialization</h2>
<p>Use the command <code>SISInitDevice</code> to initialize the device support. The arguments to this command are, in order:</p><ul>
<li>Port name.</li>
<li>VME address of the digitizer.</li>
<li>VME interrupt vector.</li>
<li>VME interrupt level (1-7).</li>
<li>Read thread priority (EPICS units).</li>
<li>Read thread stack size.</li>
<li>maxBuffers (forwarded to <code>asynNDArrayDriver</code>). At least 16 is recommended, use more if AreaDetector plugins (e.g. StdArrays) which receive arrays have blocking callbacks disabled.</li>
<li>maxMemory (forwarded to <code>asynNDArrayDriver</code>). You can use 0 since maxBuffers already limits memory use.</li>
</ul>
<h2>Database Templates</h2>
<h3>TRSIS.db</h3>
<p>The template <code>TRSIS.db</code> defines all driver-specific records except channel-specific ones.</p>
<p>Template parameters are:</p><ul>
<li><code>PREFIX</code>: Prefix of records (a colon after the prefix is implied). Must match the value passed to <code>TRBase.db</code>.</li>
<li><code>PORT</code>: Port name of the driver.</li>
<li><code>STATES_SCAN</code>: SCAN rate for refreshing device states.</li>
<li><code>ACTUAL_SCAN</code>: SCAN rate for refreshing actual channel values.</li>
<li><code>TIME_EGU</code>: EGU field for <code>lastRelTime</code> record (default: "s").</li>
</ul>
<p>For proper operation, <code>TRBase.db</code> must be loaded with <code>LNK_NEW_BURST</code> equal to "PREFIX:_on_new_burst" (with correct PREFIX). This creates a database link which link which ensures that the <code>lastHwTime</code> and <code>lastRelTime</code> records are updated.</p>
<p>The following optional macros can be used to set the default values of configuration parameters: <code>DEFAULT_TRIGGER</code>, <code>DEFAULT_PREAVERAGE</code>, <code>DEFAULT_CLOCK</code>, <code>DEFAULT_EXTRATE</code>, <code>DEFAULT_NUM_PTE</code>, <code>DEFAULT_EVENTS_BUF_SIZE</code>, <code>DEFAULT_TEST_DATA_MODE</code>. Be careful to use the correct option indices for "mbbo" records, especially for pre-average.</p>
<h3>TRSIS_Channel.db</h3>
<p>The template <code>TRSIS_Channel.db</code> defines the channel-specific records.</p>
<p>This DB file must be loaded for all 8 channels because <code>TRSIS.db</code> has links to records of all channels. This should not be a problem since <code>TRSIS_Channel.db</code> has few records and you can still avoid loading everything else channel-specific for unused channels.</p>
<p>Mandatory template parameters are:</p><ul>
<li><code>PREFIX</code>: Prefix of records (a colon is implied), this should include identification of the channel.</li>
<li><code>MPREFIX</code>: Prefix of main records (the <code>PREFIX</code> passed to <code>TRSIS.db</code>).</li>
<li><code>PORT</code>: Port name of the driver.</li>
<li><code>CHANNEL</code>: Channel number (0-7).</li>
<li><code>VOLT_EOFF</code>: Initial EOFF for voltage offset to DAC conversion.</li>
<li><code>VOLT_ESLO</code>: Initial ESLO for voltage offset to DAC conversion.</li>
</ul>
<p>Optional template parameters are:</p><ul>
<li><code>DEFAULT_DAC_VOLTAGE_OFFSET</code>: Default DAC offset can be set with the optional macro.</li>
<li><code>ENBLD</code>: Whether the channel is initially enabled (1) or disabled (0), default is enabled.</li>
</ul>
<h2>Public PVs</h2>
<p>The public <a class="el" href="framework-pvs.html">framework PVs</a> are automatically supported unless stated otherwise on this page. This page may also have notes about driver-specific semantics of certain framework PVs.</p>
<p>Be aware that the test IOC provided with this driver renames many PVs using the <a class="el" href="customizing-pvs.html">PV customization feature</a> of the framework. If you are using the test IOC, look into <code>TRSIS/TRSISApp/Db/Makefile</code> to find the correct PV names to use (or remove the renamings).</p>
<p>PVs which appear with the prefix <code>CHn</code> in the listings below are channel-specific. The actual prefix may not be <code>CHn</code> but is determined by the <code>PREFIX</code> passed to <code>TRSIS_Channel.db</code>.</p>
<h3>Device Information</h3>
<p>These PVs contain static information about the device.</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>name</code> (stringin) </td><td>The digitizer name, it is always SIS3302 (this PV is defined by the framework).   </td></tr>
<tr>
<td valign="top"><code>firmwareMajorRev</code> (longin) </td><td>The firmware major revision.   </td></tr>
<tr>
<td valign="top"><code>firmwareMinorRev</code> (longin) </td><td>The firmware minor revision.   </td></tr>
</table>
<h3>Device States</h3>
<p>These PVs represent the dynamic states.</p>
<p>All except <code>actualRawValue</code> are updated at the scan rate defined by the <code>STATES_SCAN</code> parameter to <code>TRSIS.db</code> and can also be refreshed manually using the PV <code>updateStates</code>. The <code>actualRawValue</code> PVs are updated at the scan rate <code>ACTUAL_SCAN</code> and can be refreshed manually using <code>updateActualValues</code>.</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>actualEvents</code> (longin) </td><td><p class="starttd">The value of the Actual Event Counter register.</p>
<p class="endtd">The hardware will increment this upon start of each event. The hardware clears this when armed for the next event group, so when configured with numberPTE=1 it is normal to see this equal to 0 or 1 most of the time (if pre-trigger samples are not used or used respectively).   </p>
</td></tr>
<tr>
<td valign="top"><code>clockRb</code> (mbbi) </td><td>Clock source readback (from Acquisition Control Register).   </td></tr>
<tr>
<td valign="top"><code>samplingBusy</code> (bi) </td><td><p class="starttd">Sampling busy state (from Acquisition Control Register).</p>
<p class="endtd">This means whether sampling was started via "start" condition and not yet stopped via "stop" condition or by disarming.   </p>
</td></tr>
<tr>
<td valign="top"><code>samplingLogicArmed</code> (bi) </td><td><p class="starttd">Sampling logic armed readback (from Acquisition Control Register).</p>
<p class="endtd">This does not generally reflect the framework's meaning of "armed" because in a single course of arming as defined by the framework the digitizer may disam itself and be re-armed many times.   </p>
</td></tr>
<tr>
<td valign="top"><code>stopDelayRb</code> (longin) </td><td>Stop delay register readback.   </td></tr>
<tr>
<td valign="top"><code>nextSampleAddressCh0</code> (longin) </td><td>Next sample address for channel 0 (should be the same for all channels so only one is provided).   </td></tr>
<tr>
<td valign="top"><code>CHn:actualRawValue</code> (ai) </td><td>The actual value of the analog input as a raw ADC value. The values are obtained from the "Actual Sample Value" registers.   </td></tr>
</table>
<h3>Desired Settings for Arming</h3>
<p>These PVs should be set to the desired settings before an arm request is issued. Their values are captured at the start of arming.</p>
<p>The hardware supports pre-trigger samples so the PV <code>numberPPS</code> (provided by the framework) is available.</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>trigger</code> (mbbo) </td><td><p class="starttd">The trigger mode ("soft", "autstart/FPstop", "FPstart/FPstop", "FPstart/autstop").</p>
<p>Note that this driver does not support all possible trigger configurations, especially there is no support for internal triggers.</p>
<ul>
<li>"soft": Software start or stop trigger, supports either pre- or post-trigger samples but not both. In pre-trigger operation, up to 2 samples at the end may be lost due to lack of stop delay function for the KEY_STOP command.</li>
<li>"autstart/FPstop": Front panel stop trigger, supports both pre- and post-trigger samples.</li>
<li>"FPstart/FPstop": Front panel start and stop triggers; samples between the start and stop are understood as pre-trigger samples, and optional samples after the stop are understood as post-trigger samples.</li>
<li>"FPstart/autstop": Front panel start trigger, supports post-trigger samples only.   </li>
</ul>
</td></tr>
<tr>
<td valign="top"><code>preAverage</code> (mbbo) </td><td><p class="starttd">Number of ADC samples averaged (powers of 2 from "1" to "128").</p>
<p class="endtd">Note that the sample counts are strings, numeric values for this PV are binary logarithms of the counts and go from 0 to 7 respectively. Also be aware that averaging does not apply to actual value readbacks (<code>actualRawValue</code>).   </p>
</td></tr>
<tr>
<td valign="top"><code>clock</code> (mbbo) </td><td><p class="starttd">Clock source ("100 MHz", "50 MHz", "25 MHz", "10 MHz", "1 MHz", "Ext Random", "Ext Symm", "2nd 100 MHz").</p>
<p class="endtd">If you use either of the external clocks you should set <code>extRate</code> in order to see correct times in various places.   </p>
</td></tr>
<tr>
<td valign="top"><code>extRate</code> (ao) </td><td><p class="starttd">The frequency of the external clock relevant when clock is "Ext Random" or "Ext Symm".</p>
<p class="endtd">This is used for example for the time array and calculating relative times.   </p>
</td></tr>
<tr>
<td valign="top"><code>numberPTE</code> (longout) </td><td><p class="starttd">Number of events per event group.</p>
<p>Usually this will be one meaning that each event will be processed independently by software. If it is greater than 1, then the digitizer will acquire this many events (without SW interaction) and the resulting data will be processed together (concatenated).</p>
<p class="endtd">Note: if numberPTE is greater than 1, then the time array will always start at zero (even if pre-trigger samples are used) and will contain numberPTE*numberPPS entries (in steps of 1/sample_rate).   </p>
</td></tr>
<tr>
<td valign="top"><code>eventsBufferSize</code> (longout) </td><td>Size of the ring buffer used to store event metadata from the interrupt handler until the event is processed by the read thread.   </td></tr>
<tr>
<td valign="top"><code>testDataMode</code> (mbbo) </td><td><p class="starttd">Test data mode ("Disabled", "16 bit", "32 bit").</p>
<p class="endtd">If test data is enabled the digitizer will generate an increment pattern instead of obtaining data from the ADCs.   </p>
</td></tr>
<tr>
<td valign="top"><code>testDataStart</code> (longout) </td><td><p class="starttd">The start value for the test data, relevent when test data is enabled.</p>
<p class="endtd">It must be between 0 and 65535 and the low byte must be different from 0xFE and 0xFF.   </p>
</td></tr>
</table>
<h3>Current Armed Settings</h3>
<p>With regard to the possible values and meaning of these PVs, the text in the section of the same name in <a class="el" href="framework-pvs.html">framework PVs</a> applies.</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>get_trigger</code> (mbbi) </td><td>Current armed trigger mode.   </td></tr>
<tr>
<td valign="top"><code>get_preAverage</code> (mbbi) </td><td>Current armed number of ADC samples averaged.   </td></tr>
<tr>
<td valign="top"><code>get_clock</code> (mbbi) </td><td>Current armed clock source.   </td></tr>
<tr>
<td valign="top"><code>get_extRate</code> (ai) </td><td>Current armed external clock frequency.   </td></tr>
<tr>
<td valign="top"><code>get_numberPTE</code> (ai) </td><td>Current armed number of events per event group.   </td></tr>
<tr>
<td valign="top"><code>get_eventsBufferSize</code> (ai) </td><td>Current armed size of events ring buffer.   </td></tr>
<tr>
<td valign="top"><code>get_testDataMode</code> (mbbi) </td><td>Current armed test data mode.   </td></tr>
<tr>
<td valign="top"><code>get_testDataStart</code> (ai) </td><td>Current armed test data start value.   </td></tr>
</table>
<h3>Device Requests</h3>
<p>To issue a request, write the value 1 (or the associated string value) to the PV. Behavior when writing other values is unspecified.</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>softTrigger</code> (bo) </td><td><p class="starttd">Write 1 or "softTrigger" to send a software trigger to the device.</p>
<p class="endtd">This only has an effect when the device is armed with software trigger. Note that the effect is different depending on the settings. If armed with pre-trigger samples it sends the KEY_STOP command but if armed with post-trigger samples it sends the KEY_START command to the digitizer.   </p>
</td></tr>
<tr>
<td valign="top"><code>updateActualValues</code> (bo) </td><td><p class="starttd">Write 1 or "Update" to update the actual channel value PVs from hardware (<code>actualRawValue</code>).</p>
<p class="endtd">The update is done synchronously so it is safe to process this from a DB link then immediately read the associated values.   </p>
</td></tr>
<tr>
<td valign="top"><code>updateStates</code> (bo) </td><td><p class="starttd">Write 1 or "Update" to update the PVs listed in "Device States" section from hardware (except <code>actualRawValue</code>).</p>
<p class="endtd">The update is done synchronously so it is safe to process this from a DB link then immediately read the associated values.   </p>
</td></tr>
<tr>
<td valign="top"><code>reset</code> (bo) </td><td><p class="starttd">Write 1 or "Reset" to reset the digitizer.</p>
<p class="endtd">This is only allowed while disarmed.   </p>
</td></tr>
<tr>
<td valign="top"><code>clearTimestamp</code> (bo) </td><td><p class="starttd">Write 1 or "Clear" to clear the hardware timestamp counter.</p>
<p class="endtd">This will make the hardware timestamps (<code>lastHwTime</code>) of subsequently acquired events effective relative to when the counter was reset. However, it will also cause one incorrectly computed relative time (<code>lastRelTime</code>, see description there for details).   </p>
</td></tr>
</table>
<h3>Acquisition Control</h3>
<p>These PVs affect acquisition and data processing. Changes are effective immediately.</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>CHn:dacVoltageOffset</code> (ao) </td><td><p class="starttd">Configures the voltage offset for the channel by programming its DAC.</p>
<p>The conversion from the requested voltage to the DAC setting is performed using the <code>ao</code> record's EOFF, ESLO and ASLO fields. The ASLO is hardcoded to -1/65536 while EOFF and ESLO are meant to be user-configurable. Effectively the DAC value is calculated according to the following formula (Voff is the voltage written to this record):</p>
<p>DAC = (EOFF - Voff) / ESLO * 65536</p>
<p>The test IOC provides default EOFF and ESLO which were calibrated to the device used for testing. This was done with the assumption that the input span is 10V and the center of the ADC range corresponds to Voff; in other words that the ADC values are interpreted as:</p>
<p class="endtd">V = Voff + (ADC - 32768) / 65536 * 10V   </p>
</td></tr>
<tr>
<td valign="top"><code>CHn:enabled</code> (bo) </td><td>Selects whether data for the channel is read and processed ("Disabled", "Enabled").   </td></tr>
</table>
<h3>Acquisition Information</h3>
<p>The driver generates burst IDs as suggested in the description of the <code>BURST_ID</code> PV provided by the framework.</p>
<p>The driver also provides two diagnostic relative times:</p><ul>
<li>From when the interrupt indicated the end of the event group to when the read thread started reading/processing data for the event group. This is exposed in the framework-provided PV <code>GET_BURST_END_TO_READ_END_TIME</code>.</li>
<li>From when the read thread started reading/processing data for the event group to when reading/processing was completed. This is exposed in the framework-provided PV <code>GET_READ_END_TO_DATA_PROCESSED_TIME</code>.</li>
</ul>
<p>Neither of the default PV names for these times are really suitable, but they are still used since they are readily available. The database customization feature of the framework can be used to rename them, and the included test IOC renames them to <code>InterruptProcessingTime</code> and <code>MainProcessingTime</code> respectively.</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>hwTimePeriod</code> (ai) </td><td><p class="starttd">The period of the hardware timestamp counter, in seconds.</p>
<p class="endtd">This can be used to convert raw hardware timestamps to natural units. Raw timestamps are available in the PV <code>lastHwTime</code> and are also attached as an attribute to NDArrays. This PV is defined only when armed, otherwise it is NAN.   </p>
</td></tr>
<tr>
<td valign="top"><code>lastHwTime</code> (ai) </td><td><p class="starttd">The 48-bit hardware stop timestamp of the last event group.</p>
<p class="endtd">If numberPTE is greater than one, this is the timestamp from the first event in the group. The frequency of the hardware timestamp counter depends on the settings (see <code>hwTimePeriod</code> above).   </p>
</td></tr>
<tr>
<td valign="top"><code>lastRelTime</code> (ai) </td><td><p class="starttd">The relative time from the previous event group to the last event group in natural units based on hardware timestamps.</p>
<p>It is computed by subtracting the hardware stop timestamps of the first event in each event group (modulo 2^48), converting to seconds by multiplying with <code>hwTimePeriod</code> and then converting from seconds to the unit determined by <code>TIME_UNIT_INV</code>. Note that EGU will be the parameter <code>TIME_EGU</code> passed to <code>TRSIS.db</code>. For the first event group after arming this is relative to when the digitizer was armed.</p>
<p class="endtd">When <code>clearTimestamp</code> is used to reset the timestamp counter, it is expected that the lastRelTime of the first event acquired after clearing will be incorrect (likely very large). This is because the sofware does not try to track which events were acquired before/after clearing and simply subtracts timestamps of adjacent events.   </p>
</td></tr>
<tr>
<td valign="top"><code>delayedArmsCount</code> (longin) </td><td><p class="starttd">Counts how many times rearming of the digitizer was delayed due lack of buffer space for the current acquisition. This can be used to detect overload of the IOC.</p>
<p class="endtd">The count is initialized to zero when acquisition is started and is incremented whenever the interrupt handler was not able to rearm the digitizer because there was not enough space in the sample buffer or the events ring buffer (see <code>eventsBufferSize</code>). The PV is updated with every processed burst not immediately when this occurs.   </p>
</td></tr>
</table>
<h3>Note about Clock PVs</h3>
<p>Because the hardware only supports several discrete clock sources, some clock-related PVs provided by the framework do not have any real function with this driver. The unsupported PVs are:</p><ul>
<li><code>_requestedSampleRate</code>, <code>GET_ARMED_REQUESTED_SAMPLE_RATE</code>,</li>
<li><code>ACHIEVABLE_SAMPLE_RATE</code>, <code>ACHIEVABLE_SAMPLE_RATE</code>.</li>
</ul>
<p>These PVs can be excluded from an IOC by passing <code>NOCLK=#</code> to <code>TRBase.db</code>. This is done in the test IOC.</p>
<p>However, <code>GET_DISPLAY_SAMPLE_RATE</code> is available and reflects the selected clock source while armed (and <code>extRate</code> in case of external clock). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
