<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Transient Recorder Framework: List of Framework PVs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Transient Recorder Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">List of Framework PVs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page describes the public PVs implemented by the Transient Recorder framework as well as internal PVs meant to be used by driver-specific database code.</p>
<p>For instructions for loading the correct DB files, consult the <a class="el" href="index.html">main page</a>.</p>
<p>The names of all the PVs documented here can be customized (see <a class="el" href="customizing-pvs.html">Customizing PVs</a>).</p>
<p>Most of the records in this section are provided by the database file <code>TRBase.db</code>. However, channel-specific records (containing <code>CH&lt;N&gt;</code> in their name) originate from <code>TRChannel.db</code> or <code>TRChannelWaveform.db</code>.</p>
<p>The common record prefixes are omitted in these listings. They are specified as database template parameters to the associated database files. Note that channel-specific database files may be loaded with a prefix different than <code>CH&lt;N&gt;</code>, perhaps with a name more descriptive of the purpose of the channel.</p>
<h2>Device Information</h2>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>name</code> (stringin) </td><td><p class="starttd">The device name or model.</p>
<p class="endtd">It is the value that the driver set using <a class="el" href="classTRBaseDriver.html#aafad865f171e12b63b97e642ad59aae4">TRBaseDriver::setDigitizerName</a> or the asyn port name if the driver did not call this function.   </p>
</td></tr>
</table>
<h2>Desired Settings for Arming</h2>
<p>These PVs should be set to the desired settings before an arm request is issued. Changing them has no immediate effect, but their values are caputed at the start of the arm procedure. The one exception is the <code>ACHIEVABLE_SAMPLE_RATE</code> which must not be written but is automatically calculated from the desired clock settings.</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>autoRestart</code> (bo) </td><td><p class="starttd">Selects single-burst mode or determined by <code>NUM_BURSTS</code>.</p>
<p><code>Off</code> means to disarm after the first burst, <code>On</code> means the number of bursts is selected by <code>NUM_BURSTS</code>. The default os <code>On</code>.</p>
<p class="endtd">It is possible to customize the ZNAM/ONAM fields by passing the macros <code>AUTORESTART_ZNAM</code>/<code>AUTORESTART_ONAM</code> to <code>TRBase.db</code>.   </p>
</td></tr>
<tr>
<td valign="top"><code>NUM_BURSTS</code> (longout) </td><td><p class="starttd">When <code>autoRestart</code> is <code>On</code>, selects the number of bursts.</p>
<p class="endtd">Zero or a negative value means to process an unlimited number bursts, a positive value means to process the fixed number of bursts then disarm.   </p>
</td></tr>
<tr>
<td valign="top"><code>numberPTS</code> (longout) </td><td>Number of post-trigger samples (of each channel).   </td></tr>
<tr>
<td valign="top"><code>numberPPS</code> (longout) </td><td><p class="starttd">Total number of samples for prePostTrigger mode.</p>
<p class="endtd">This is only relevant when arming in prePostTrigger mode. In that case, it should be the total number of samples per burst (pre + post samples), and must be greater than <code>numberPTS</code>.   </p>
</td></tr>
<tr>
<td valign="top"><code>_requestedSampleRate</code> (ao) </td><td><p class="starttd">This is an internal record designed to be written by driver-specific database code to forward the sample rate requested by the user to the framework.</p>
<p>Writing this PV will result in the function <a class="el" href="classTRBaseDriver.html#abdca3e00a0ab8355d42851fca6d3a4c4">TRBaseDriver::requestedSampleRateChanged</a> being called, and the value written will be available through the function <a class="el" href="classTRBaseDriver.html#a94f98559d9a9208e18c7438bec648f6a">TRBaseDriver::getRequestedSampleRate</a>.</p>
<p>For an example of database code writing this record, see the implementation in the General Standards driver (<code>TRGeneralStandards.db</code>). There, the value of <code>_requestedSampleRate</code> is computed based on the records <code>clock</code> and <code>CUSTOM_SAMPLE_RATE</code>.</p>
<p class="endtd">This record can be excluded by passing <code>NOCLK=#</code> to <code>TRBase.db</code>.   </p>
</td></tr>
<tr>
<td valign="top"><code>ACHIEVABLE_SAMPLE_RATE</code> (ai) </td><td><p class="starttd">Provides the sample rate (Hz) that would actually be achieved.</p>
<p>This is computed based on the desired sample clock configuration (<code>_requestedSampleRate</code> but possibly also driver-specific settings). The value of this record is provided by the function <code><a class="el" href="classTRBaseDriver.html#a43f2a60d33275dc1ca9d9bfd03edc9b5" title="Sets the achievable sample rate corresponding to the requested sample rate. ">TRBaseDriver::setAchievableSampleRate</a></code>.</p>
<p>Note that because calculation of the clock configuration may be performed asynchronously, this PV is not guaranteed to reflect the new settings immediately after the settings are changed.</p>
<p class="endtd">This record can be excluded by passing <code>NOCLK=#</code> to <code>TRBase.db</code>.   </p>
</td></tr>
</table>
<h2>Arming and Disarming</h2>
<p>These records are for requesting arming or disarming and for determining the current state of the arming sequence.</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>arm</code> (mbbo) </td><td><p class="starttd">This PV both indicates the current armed state and can be used to request arming or disarming.</p>
<p>Possible values of this PV are:</p><ul>
<li><code>disarm</code> (device is disarmed; write to request disarming),</li>
<li><code>postTrigger</code> (device is armed without pre-samples; write to request arming),</li>
<li><code>prePostTrigger</code> (device is armed with pre-samples; write to request arming),</li>
<li><code>busy</code> (device is being armed or disarmed),</li>
<li><code>error</code> (there has been an error).</li>
</ul>
<p>It is only allowed to write <code>disarm</code>, <code>postTrigger</code> or <code>prePostTrigger</code> to this PV Writes of other values will be ignored and the PV will remain at its original value.</p>
<p>Writing <code>disarm</code>, <code>postTrigger</code> or <code>prePostTrigger</code> will normally result in a transition to the <code>busy</code> state. Only at the end of arming/disarming will the value change to the value that was written (or to <code>error</code>).</p>
<p>If <code>postTrigger</code> or <code>prePostTrigger</code> is written while the state is not <code>disarm</code>, disarming and re-arming will be performed. Therefore, writing <code>postTrigger</code> or <code>prePostTrigger</code> is acceptable at any time to get the device armed with the current settings irrespective of the current state.</p>
<p class="endtd">The <code>prePostTrigger</code> option is only available when the device supports pre-samples.   </p>
</td></tr>
<tr>
<td valign="top"><code>set_arm</code> (mbbo) </td><td><p class="starttd">This PV can be used for arm or disarm requests.</p>
<p>Writing <code>disarm</code>, <code>postTrigger</code> or <code>prePostTrigger</code> to this PV is equivalent to writing it into <code>arm</code>. Conversly, writing to <code>arm</code> will update <code>set_arm</code>, reflecting the last request.</p>
<p>The reason for this PV is that it does not have the special values <code>busy</code> and <code>error</code> defined, which is useful with certain GUIs, so that these are not shown as values that can be written.</p>
<p class="endtd">The <code>prePostTrigger</code> option is only available when the device supports pre-samples.   </p>
</td></tr>
</table>
<h2>Current Armed Settings</h2>
<p>These PVs hold the settings that the device has been armed with. When the device is not armed, they contain placeholder values such as <code>NAN</code> for numeric values and <code>N/A</code> for choice values. These PVs must not be written.</p>
<p>Note that for <code>mbbi</code> records, the values are not listed, and are the same as for the corresponding desired-setting PVs with the addition of <code>N/A</code>.</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>GET_ARMED_NUM_BURSTS</code> (ai) </td><td><p class="starttd">Current effective number of bursts to be processed.</p>
<p class="endtd">This is based on the <code>autoRestart</code> and <code>NUM_BURSTS</code> settings used for arming. Zero means unlimited bursts, positive means that number of bursts.   </p>
</td></tr>
<tr>
<td valign="top"><code>get_numberPTS</code> (ai) </td><td>Current armed number of post-trigger samples; see <code>numberPTS</code>.   </td></tr>
<tr>
<td valign="top"><code>get_numberPPS</code> (ai) </td><td>Current armed total number of samples for prePostTrigger mode; see <code>numberPPS</code>.   </td></tr>
<tr>
<td><code>GET_ARMED_REQUESTED_SAMPLE_RATE</code> (ai) </td><td valign="top"><p class="starttd">Current armed requested sample rate; see <code>_requestedSampleRate</code>.</p>
<p class="endtd">This record can be excluded by passing <code>NOCLK=#</code> to <code>TRBase.db</code>.   </p>
</td></tr>
<tr>
<td valign="top"><code>GET_SAMPLE_RATE</code> (ai) </td><td><p class="starttd">Current armed achievable sample rate; see <code>ACHIEVABLE_SAMPLE_RATE</code>.</p>
<p class="endtd">This record can be excluded by passing <code>NOCLK=#</code> to <code>TRBase.db</code>.   </p>
</td></tr>
<tr>
<td valign="top"><code>GET_DISPLAY_SAMPLE_RATE</code> (ai) </td><td><p class="starttd">Current armed display sample rate.</p>
<p class="endtd">This is the value that was returned by the driver in <a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">TRBaseDriver::checkSettings</a> via <a class="el" href="classTRArmInfo.html#ae59f205cc9afac4649a093111817775f">TRArmInfo::rate_for_display</a>. It also the same sample rate that the time array (<code>TIME_DATA</code>) is based on.   </p>
</td></tr>
</table>
<h2>Acquisition Information</h2>
<p>These PVs provide the channel data and additional information about burst processing.</p>
<p>Note that the size (<code>NELM</code>) of all waveform records is determined by the value of the <code>SIZE</code> parameter of associated database templates (<code>TRBase.db</code> and <code>TRChannelData.db</code>).</p>
<p>The data type of the waveforms is determined by the <code>FTVL</code> parameter to <code>TRChannelData.db</code> and is <code>DOUBLE</code> by default (if this is changed then <code>WF_DTYP</code> also needs to be adjusted). However be aware that the digitizer driver determines the data type of NDArrays it submits. If the NDArray data type does not match <code>FTVL</code>, the StdArrays plugin will convert the data.</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>perSecond</code> (longin) </td><td><p class="starttd">The number of bursts per second.</p>
<p>This PV is updated each second to the number of bursts which have been processed in the previous second.</p>
<p class="endtd">It is possible to add custom fields to this record by passing the macro <code>PERSECOND_FIELDS</code> to <code>TRBase.db</code>.   </p>
</td></tr>
<tr>
<td valign="top"><code>TIME_DATA</code> (waveform) </td><td><p class="starttd">The relative sample time waveform (unit: see <code>TIME_UNIT_INV</code>).</p>
<p>This is recalculated whenever the device is armed. It will consist of time values for pre-samples (if pre-samples are enabled) and time values for post-samples. The pre-sample times will be negative, the first post-sample time will be 0 and the remaining post-sample times will be positive. The difference between subsequent sample times will be 1/<code>GET_DISPLAY_SAMPLE_RATE</code>. However drivers are able to override the calculation of the time array, so the semantics may be different.</p>
<p class="endtd">The <code>EGU</code> field of this record corresponds to the macro <code>TIME_EGU</code> passed to <code>TRBase.db</code>, which is "s" by default if not passed.   </p>
</td></tr>
<tr>
<td valign="top"><code>TIME_UNIT_INV</code> (ao) </td><td><p class="starttd">The unit for <code>TIME_DATA</code>, as fractions of a second, e.g. 1000 for ms.</p>
<p>The initial value is according to the <code>TIME_UNIT_INV</code> macro passed to <code>TRBase.db</code>, which itself has the default value 1 (second).</p>
<p class="endtd">Changes to this PV during operation will be reflected in new data (newly generated NDArrays). Note that changes do not affect the EGU of the data waveforms, it is your responsibility to keep these in sync if needed.   </p>
</td></tr>
<tr>
<td valign="top"><code>CH&lt;N&gt;:DATA</code> (waveform) </td><td><p class="starttd">The data waveform for channel N.</p>
<p>The timestamp of the data waveform is based on the timestamp of the associated NDArray, which is itself obtained from the Asyn updateTimeStamp function on the main port (not the channels port).</p>
<p>While this is not reflected in this waveform record, note that the NDArrays generated by the channel ports will be tagged with an attribute <code>READ_SAMPLE_RATE</code> which will be equal to <code>GET_DISPLAY_SAMPLE_RATE</code>.</p>
<p class="endtd">It is possible to define a link to be processed after data is updated, by passing the macro <code>DATA_UPD_LNK</code> to <code>TRChannelData.db</code>.   </p>
</td></tr>
<tr>
<td valign="top"><code>CH&lt;N&gt;:DATA_SNAPSHOT</code> (waveform) </td><td><p class="starttd">The slow-updating data waveform for channel N.</p>
<p>The data and timestamp will match the <code>CH&lt;N&gt;:DATA</code> waveform at the time the snapshot was made.</p>
<p>The update rate of slow waveforms is defined by the parameter <code>SNAP_SCAN</code> to the database template <code>TRChannelData.db</code>. Each update period, the update is made only if the <code>DATA</code> waveform has been updated since the previous time. That is, there will be no redundant periodic CA monitor events if there was no new data.</p>
<p>It is possible to define a link to be processed after snapshot data is updated, by passing the macro <code>SNAP_UPD_LNK</code> to <code>TRChannelData.db</code>.</p>
<p class="endtd">These snapshot records can be disabled by passing the macro <code>SNAPSHOT=#</code> to <code>TRChannelData.db</code>.   </p>
</td></tr>
<tr>
<td valign="top"><code>GET_BURST_ID</code> (longin) </td><td><p class="starttd">The identification number of the last burst.</p>
<p>This PV will be updated for every burst with the burst ID of that burst. Burst IDs are generated by the driver, but the expectation is that the first burst ID will be zero, each subsequent ID will be incremented by one up to 2<sup>31</sup>-1, after which point it will wrap back to zero. The expectation is also that the ID is not reset to zero when arming again.</p>
<p class="endtd">It is possible to specify a database link to be processed on each new burst, by passing the macro <code>LNK_NEW_BURST</code> to <code>TRBase.db</code>. This link would be processed after framework PVs with burst information are updated (e.g. <code>GET_LAST_BURST_TIME</code>).   </p>
</td></tr>
<tr>
<td valign="top"><code>GET_LAST_BURST_TIME</code> (stringin) </td><td><p class="starttd">The time-and-date string of the last processed burst, based on the burst timestamp.</p>
<p class="endtd">The format of the timestamp is according to the <code>TIMESTAMP_FMT</code> macro passed to <code>TRBase.db</code> (as understood by the EPICS Soft Timestamp device support). If the macro is not passed the default is <code>Y-m-d H:M:S.%06f</code>.   </p>
</td></tr>
<tr>
<td valign="top"><code>GET_BURST_START_TO_BURST_END_TIME</code> (ai) </td><td><p class="starttd">The time from when the start of the burst was detected to when the end of the burst was detected, for the last processed burst.</p>
<p class="endtd"><code>NAN</code> if the driver did not provide this information.   </p>
</td></tr>
<tr>
<td valign="top"><code>GET_BURST_END_TO_READ_END_TIME</code> (ai) </td><td><p class="starttd">The time from when the end of the burst was detected to when the burst has been read to memory, for the last processed burst.</p>
<p class="endtd"><code>NAN</code> if the driver did not provide this information.   </p>
</td></tr>
<tr>
<td valign="top"><code>GET_READ_END_TO_DATA_PROCESSED_TIME</code> (ai) </td><td><p class="starttd">The time from when the burst has been read to memory to when the burst data has been processed (sent into AreaDetector).</p>
<p class="endtd"><code>NAN</code> if the driver did not provide this information.   </p>
</td></tr>
</table>
<h2>Acquisition Control</h2>
<p>These PVs are used to control the acquisition process. Changes to the values of these PVs are effective immediately (as opposed to values being captured at the start of arming).</p>
<table class="doxtable">
<tr>
<th>PV name, record type </th><th>Description  </th></tr>
<tr>
<td valign="top"><code>SET_TEST_READ_SLEEP_TIME</code> (ao) </td><td><p class="starttd">Artificial time delay after processing a burst (in seconds).</p>
<p>This allows inserting a time delay to the read loop each time after a burst is processed. It is useful for testing hardware buffer overflow.</p>
<p class="endtd">The default is zero.   </p>
</td></tr>
<tr>
<td valign="top"><code>CH&lt;N&gt;:ENABLE_ARRAY_CALLBACKS</code> (bo) </td><td><p class="starttd">Enable AreaDetector NDArray callbacks for the channel (<code>Off</code> or <code>On</code>).</p>
<p>If callbacks are <code>Off</code>, the channels port will not generate NDArray callbacks for this channel, and consequently its data will not appear to any NDArray plugins connected to the channel, including StdArrays plugins supporting the data waveform records.</p>
<p class="endtd">The default is <code>On</code>.   </p>
</td></tr>
<tr>
<td valign="top"><code>CH&lt;N&gt;:ENABLE_UPDATE_ARRAYS</code> (bo) </td><td><p class="starttd">Enable updating of the cached NDArray for the channel (<code>Off</code> or <code>On</code>).</p>
<p>If this is <code>On</code>, then <code>pArrays[channel_index]</code> in the channels port will be updated each time a new NDArray is generated for this channel, otherwise it will not be. Also note that the framework will clear all arrays from <code>pArrays</code> at the start of arming.</p>
<p>Turning this off saves some memory as it allows each NDArray to be freed after it is processed.</p>
<p class="endtd">The default is <code>On</code>.   </p>
</td></tr>
<tr>
<td valign="top"><code>CH&lt;N&gt;:SET_BLOCKING_CALLBACKS</code> (bo) </td><td><p class="starttd">Enable/disable blocking-callbacks for the StdArrays port of this channel (<code>Off</code> or <code>On</code>).</p>
<p><b>Warning:</b> disabling blocking callbacks will start the callback processing thread for this channel if it has not been started yet. If there is not enough memory, this will result in memory allocation failures likely followed by a complete failure of the IOC.</p>
<p class="endtd">The default is determined by the arguments when initializing the StdArrays ports.   </p>
</td></tr>
<tr>
<td valign="top"><code>CH&lt;N&gt;:GET_BLOCKING_CALLBACKS</code> (bi) </td><td><p class="starttd">Readback value of the blocking-callbacks setting for this channels (<code>Off</code> or <code>On</code>).</p>
<p class="endtd">This is a readback only and must not be written.   </p>
</td></tr>
</table>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
