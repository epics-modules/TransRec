<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Transient Recorder Framework: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Transient Recorder Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Main Page </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the documentation of the Transient Recorder Framework for AreaDetector.</p>
<p>Transient recorders, commonly call "digitizers", are devices which capture analog data in response to specific trigger events. The Transient Recorder Framework aims to simplify the integration of digitizers into AreaDetector and EPICS.</p>
<p>The first driver developed using the framework is for General Standards 16AI64SSA/C digitizers. Actually the framework is the result of refactoring an older EPICS integration of these digitizer models. While this documentation aims to document the framework extensively and sufficiently to develop a new driver, the General Standards driver may still be useful as a reference.</p>
<p>Note that the much of information provided on this page is only a summary; the class and method descriptions provide more detailed documentation. All the relevant documentation must be consulted when implementing a driver, as otherwise important details may be missed. This is especially important due to various synchronization requirements, such as which methods are or must be called with the asyn port lock and which without.</p>
<p>The most important features provided by the framework are management of the <b>arming and disarming sequence</b>, management of <b>configuration</b> used for acqusition, and an implementation of a generic burst <b>reading and processing loop</b>.</p>
<h1>Main Concepts</h1>
<p>A Transient Recorder <b>driver</b> is a set of source code that implements support for a group of digitizers using the Transient Recorder framework. In order to use the framework, a driver needs to implement a class derived from <a class="el" href="classTRBaseDriver.html">TRBaseDriver</a>. Since this derived class is how the driver presents itself to the framework, the term <em>driver</em> is often used in this documentation to refer to this derived class.</p>
<p>A <b>channel</b> is a single source of analog time-lapse data from the digitizer. The framework supports an arbitrary number of channels, but the maximum number of channels must be specified at construction (using <a class="el" href="classTRBaseConfig.html">TRBaseConfig</a>). The framework does not itself provide configuration for selection of active channels because each hardware has its own capabilities.</p>
<p>A <b>burst</b> is the data resulting from a trigger event, spanning one or more channels. It is the responsibility of the driver to obtain the data associated with a burst from the hardware and provide it to the framework. On the other hand, the framework is responsible for distributing this data into AreaDetector and EPICS.</p>
<p>To <b>arm</b> the device means to configure it to be ready to receive triggers and generate data. To <b>disarms</b> the device means to bring it back to an idle state where it will not react to triggers or generate data. Arming and disarming consists not only of actions performed on hardware but also any internal setup withing the driver to initiate and cease relevant operations.</p>
<p>A (Transient Recorder) <b>configuration parameter</b> is an abstract variable controllable through the external (EPICS) interface which controls some aspect of operation while the device is armed. A configuration parameter is represented by the class <a class="el" href="classTRConfigParam.html">TRConfigParam</a>. The defining feature of Transient Recorder configuration parameters is that the framework takes a snapshot of all configuration parameters at the beginning of arming. For details, refer to section <a href="#configuration-parameters">Configuration Parameters</a>.</p>
<h1><a class="anchor" id="arming-acquisition-disarming"></a>
Arming, Acquisition and Disarming</h1>
<p>The <b>arming sequence</b> includes all actions associated with arming, data processing and disarming. The framework drives the arming sequence and the driver only implements its device-specific parts.</p>
<p>All parts of the arming sequence are executed on a single thread managed by the framework. This is seen to be a major benefit because it absolves the driver of certain (but not all) synchronization considerations.</p>
<p>The arming sequence beings with an external request to arm the device. From that point on, it consists of the actions listed below.</p>
<ul>
<li><b>Waiting for preconditions</b>: <a class="el" href="classTRBaseDriver.html#ab373077c14ddd263a7bc6dd11cf6e785">TRBaseDriver::waitForPreconditions</a> In this function the driver has the chance to wait for any preconditions for arming to be satisfied. This is meant to be used to wait for internal asynchronous operations within the driver to complete.</li>
<li><b>Verifying the configuration</b>: <a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">TRBaseDriver::checkSettings</a>. In this function the driver verifies that the desired configuration for acquisition is valid and provides certain information to the framework. The framework itself also performs basic verification of a few generic configuration parameters before calling this function.</li>
<li><b>Starting the acqusition</b>: <a class="el" href="classTRBaseDriver.html#a070e41e3e124ce83bc44a5214814f2aa">TRBaseDriver::startAcquisition</a>. In this function the driver configures the hardware to be ready to react to triggers and capture data, as well as prepares itself to be ready to receive burst data from the hardware.</li>
<li><b>Reading bursts</b>. The framework implements the infrastructure for a generic data reading and processing loop (called simply the <b>read loop</b>). For more information, see rection <a href="#read-loop">Read Loop</a>.</li>
<li><b>Stopping the acquisition</b>: <a class="el" href="classTRBaseDriver.html#a5692c5734f8b00330a98d0c4f5bf17db">TRBaseDriver::stopAcquisition</a>. Different events will trigger stopping the acquisition, such as a disarm request from the external interface, the requested number of bursts having been processed, or a disarm request from the driver.</li>
</ul>
<h1>Clock Calculation</h1>
<p>The driver is responsible for calculating the achievable sample rate based on the requested sample rate. When the framework calls the virtual function <a class="el" href="classTRBaseDriver.html#abdca3e00a0ab8355d42851fca6d3a4c4">TRBaseDriver::requestedSampleRateChanged</a>, the driver must calculate the achievable sample rate corresponding to <a class="el" href="classTRBaseDriver.html#a94f98559d9a9208e18c7438bec648f6a" title="Returns the requested sample rate. ">TRBaseDriver::getRequestedSampleRate</a> and report it to to framework by calling <a class="el" href="classTRBaseDriver.html#a43f2a60d33275dc1ca9d9bfd03edc9b5">TRBaseDriver::setAchievableSampleRate</a>. If the calculation is time-consuming, it should be done asynchronously on a separate thread (<a class="el" href="classTRWorkerThread.html">TRWorkerThread</a> can be used) and <a class="el" href="classTRBaseDriver.html#ab373077c14ddd263a7bc6dd11cf6e785">TRBaseDriver::waitForPreconditions</a> must be implemented to wait for any ongoing calculation to complete. See the General Standards driver for an example of asynchronous clock calculation.</p>
<h1>Common Configuration</h1>
<p>After <a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">TRBaseDriver::checkSettings</a> is called, the driver will be able to query certain common configuration parameters and must behave according their values.</p>
<ul>
<li><a class="el" href="classTRBaseDriver.html#a6e63889bd84f60be719d15dfd405ab4d">TRBaseDriver::getNumBurstsSnapshot</a> : The desired number of bursts to be processed. If the driver is using the framework's read loop, there is no need to handle this.</li>
<li><a class="el" href="classTRBaseDriver.html#ad64d62a21e6555851c8c85b9942579b9">TRBaseDriver::getNumPostSamplesSnapshot</a> : Number of post-trigger samples.</li>
<li><a class="el" href="classTRBaseDriver.html#a43bd33f4704b42fe5c6255f86e563db8">TRBaseDriver::getNumPrePostSamplesSnapshot</a> : Total number of samples for prePostTrigger mode. Zero means pre-samples are to be disabled. If the driver does not declare support for pre-samples (<a class="el" href="classTRBaseConfig.html#a875482f9c94f69f764e489eced30e451">TRBaseConfig::supports_pre_samples</a> was not set to true), this will be always be zero.</li>
<li><a class="el" href="classTRBaseDriver.html#a50b6399f6598270f2f1ccf899f9652cb">TRBaseDriver::getRequestedSampleRateSnapshot</a> and <a class="el" href="classTRBaseDriver.html#aa82a97ddd260bf97b0ccfba5b620b4ab">TRBaseDriver::getAchievableSampleRateSnapshot</a> : The requested and corresponding calculated achievable sample rate.</li>
</ul>
<h1><a class="anchor" id="configuration-parameters"></a>
Configuration Parameters</h1>
<p>Configuration parameters (<a class="el" href="classTRConfigParam.html">TRConfigParam</a>) should be used for runtime-configurable parameters which affect operation while the device is armed (or being armed) but whose modification during acqusition or arming is not supported.</p>
<p>Drivers are free to define any number of configuration parameters. This is done by including <a class="el" href="classTRConfigParam.html" title="Transient Recorder configuration parameter. ">TRConfigParam</a> classes as members of the driver class and initializing them using <a class="el" href="classTRBaseDriver.html#a1ffec79dcf8c5fb8ba5ffd3ce87c121f">TRBaseDriver::initConfigParam</a> in the constructor.</p>
<p>Just after the function <a class="el" href="classTRBaseDriver.html#ab373077c14ddd263a7bc6dd11cf6e785">TRBaseDriver::waitForPreconditions</a> returns successfully, the framework will make snapshots of the current set of configuration parameters. Hence, the framework differrentiates between the <b>desired</b> value of the parameter, which can be chaned at any time through the external (EPICS) interface, and the <b>snapshot</b> value of the parameter, which is meant to be used by the driver.</p>
<p>The desired value is implemented as an asyn parameter while the snapshot value is simply a (private) variable in <a class="el" href="classTRConfigParam.html" title="Transient Recorder configuration parameter. ">TRConfigParam</a>.</p>
<p>There is another asyn parameter associated with each configuration parameter: the <b>effective</b> value parameter, which reports the current value of the parameter that the device is armed with.</p>
<p>When the device is not armed, the effective value will be an <em>invalid value</em>, which is specified when initializing the configuration parameter. After successfully calling <a class="el" href="classTRBaseDriver.html#ab1ddb213060a17f0c9c66b9a2d562134">TRBaseDriver::checkSettings</a>, the framework will set the effective values of all configuration parameters to the snapshot values. However, drivers may call <a class="el" href="classTRConfigParam.html#a6901ebf75d6a253f7eaa4df331bf0210">TRConfigParam::setIrrelevant</a> to mark specific parameters as irrelevent. The effective values of those will remain at invalid values instead of being set to the snapshot values.</p>
<p>After the device is disared, the framework will revert all the effective values back to invalid values.</p>
<h1><a class="anchor" id="read-loop"></a>
Read Loop</h1>
<p>The read loop is the central part of the arming sequence. It is executed on the same thread as the rest of the arming sequence, between <a class="el" href="classTRBaseDriver.html#a070e41e3e124ce83bc44a5214814f2aa">TRBaseDriver::startAcquisition</a> and <a class="el" href="classTRBaseDriver.html#a5692c5734f8b00330a98d0c4f5bf17db">TRBaseDriver::stopAcquisition</a>.</p>
<p>The read loop is optional; refer to <a class="el" href="classTRBaseDriver.html#a89eb4c8f4c81286393e2c48c6ee93074">TRBaseDriver::readBurst</a> for more detailed documentation on how to not use the read loop. However it is assumed that most drivers will leverage the framework's read loop, and this should be possible for any hardware which uses FIFO buffering.</p>
<p>If the driver uses the read loop, the framework will internally implement the feature to disarm after a specific number of bursts have been processed. Otherwise, drivers should implement this internally, with the assistance of the functions <a class="el" href="classTRBaseDriver.html#a6e63889bd84f60be719d15dfd405ab4d">TRBaseDriver::getNumBurstsSnapshot</a> and <a class="el" href="classTRBaseDriver.html#ab26e54e4756b4255d88b2e894967fe02">TRBaseDriver::requestDisarmingFromDriver</a>.</p>
<p>Additionally, the read loop provides some assistance for implementation of handling overrun of the hardware FIFO buffer, in the form of the virtual function <a class="el" href="classTRBaseDriver.html#ab04f2ac00edeb64b1cb3ac7b383f47a5">TRBaseDriver::checkOverflow</a> and automatically restarting acquisition after the remaining buffered bursts have been read.</p>
<p>The read loop performs the following actions repeatedly:</p>
<ul>
<li>Waiting for and <b>reading a single burst</b>: <a class="el" href="classTRBaseDriver.html#a89eb4c8f4c81286393e2c48c6ee93074">TRBaseDriver::readBurst</a>. The driver is supposed to store the burst data internally at this point.</li>
<li>Optionally, checking if <b>buffer overflow</b> has occurred: <a class="el" href="classTRBaseDriver.html#ab04f2ac00edeb64b1cb3ac7b383f47a5">TRBaseDriver::checkOverflow</a>. This is called only if buffer overflow has not yet occurred.</li>
<li><b>Processing the data</b> of the burst: <a class="el" href="classTRBaseDriver.html#ad622b8da2b13c745691b14fb9a1c6052">TRBaseDriver::processBurstData</a>. From this function, the driver should use the <a class="el" href="classTRChannelDataSubmit.html">TRChannelDataSubmit</a> class to submit burst data for different channels to the framework.</li>
</ul>
<h1>Channels Port</h1>
<p>Channel data is submitted into the AreaDetector framework through the <b>channels port</b>. The channels port is based on the class <a class="el" href="classTRChannelsDriver.html">TRChannelsDriver</a> and is a separate port from the main port that is based on <a class="el" href="classTRBaseDriver.html">TRBaseDriver</a>.</p>
<p>The reason that a separate port is used is that the channels port needs to be an asyn multi-device port since it provides channel-specific data and configuration, while the parameters of the main port are not channel-specific. Also note that <a class="el" href="classTRBaseDriver.html" title="Central class of the Transient Recorder framework for transient recorders (digitizers). ">TRBaseDriver</a> is based on asynPortDriver while <a class="el" href="classTRChannelsDriver.html" title="An asynNDArrayDriver-based class though which burst data is submitted into the AreaDetector framework...">TRChannelsDriver</a> is based on asynNDArrayDriver.</p>
<p>The framework will itself create an instance of the channels driver. It is possible (but not in any way required) for a driver to define its own class derived from <a class="el" href="classTRChannelsDriver.html" title="An asynNDArrayDriver-based class though which burst data is submitted into the AreaDetector framework...">TRChannelsDriver</a>; this is done by overriding <a class="el" href="classTRBaseDriver.html#a8ca35e2067f89c2aa4e6f07e9d18aea5">TRBaseDriver::createChannelsDriver</a>.</p>
<h1>Port Initialization</h1>
<p>The driver will need to provide its own initialization function that creates an instance of the driver. Note that the initialization function must call <a class="el" href="classTRBaseDriver.html#a2b5578f3d5e8961ab24cb85aa12762df" title="Complete initialization of the class. ">TRBaseDriver::completeInit</a> after constructing the driver.</p>
<p>In order to bring channel data to waveform records, the standard AreaDetector StdArrays plugins need to be used, one for each channel. The framework provides a database template for this (<code>TRChannelData.db</code>, see below), but the StdArrays plugins need to be initialized manually.</p>
<h1><a class="anchor" id="database-templates"></a>
Database Templates</h1>
<h2>TRBase.db</h2>
<p>The database template <code>TRBase.db</code> defines the common records corresponding to functions implemented by <a class="el" href="classTRBaseDriver.html">TRBaseDriver</a>. This template requires the following macros:</p><ul>
<li><code>PREFIX</code>: Prefix of records (a colon after the prefix is implied).</li>
<li><code>PORT</code>: Port name of the driver based on <a class="el" href="classTRBaseDriver.html" title="Central class of the Transient Recorder framework for transient recorders (digitizers). ">TRBaseDriver</a>.</li>
<li><code>SIZE</code> - Waveform size (NELM) for the time array.</li>
<li><code>PRESAMPLES</code> - <code>#</code> if presamples are not supported, empty if supported</li>
</ul>
<p>Optional macros are:</p><ul>
<li><code>TIME_UNIT_INV</code>: The unit for the time array, as fractions of a second, e.g. 1000 for ms (default: 1 - second).</li>
<li><code>TIME_EGU</code>: EGU field for <code>TIME_DATA</code> (default: "s"). Should correspond to <code>TIME_UNIT_INV</code>.</li>
<li><code>TIMESTAMP_FMT</code>: Timestamp format for <code>GET_LAST_BURST_TIME</code> (default: <code>Y-m-d H:M:S.%06f</code>).</li>
<li><code>PERSECOND_FIELDS</code>: Extra fields for perSecond record (default: empty).</li>
<li><code>AUTORESTART_ZNAM</code>: ZNAM for autoRestart record (default: Off).</li>
<li><code>AUTORESTART_ONAM</code>: ONAM for autoRestart record (default: On).</li>
<li><code>LNK_NEW_BURST</code>: Link to process after information for a new burst is available (default: empty).</li>
<li><code>NOCLK</code>: Set to "#" to disable sample rate configuration records (default: empty - enabled).</li>
</ul>
<p>The following optional macros can be used to set the default values of configuration parameters: <code>DEFAULT_AUTORESTART</code>, <code>DEFAULT_NUM_BURSTS</code>, <code>DEFAULT_NUM_PTS</code>, <code>DEFAULT_NUM_PPS</code>.</p>
<h2>TRChannel.db</h2>
<p>The database template <code>TRChannel.db</code> provides channel-specific configuration records supported by the class <a class="el" href="classTRChannelsDriver.html">TRChannelsDriver</a>. It requires the following macros:</p><ul>
<li><code>PREFIX</code>: Prefix of records (a colon is implied), this should include identification of the channel.</li>
<li><code>CHANNELS_PORT</code>: Port name of the channels driver. This is the name of the base driver with the suffix <code>_channels</code>.</li>
<li><code>CHANNEL</code>: Channel number (asyn address for <a class="el" href="classTRChannelsDriver.html" title="An asynNDArrayDriver-based class though which burst data is submitted into the AreaDetector framework...">TRChannelsDriver</a>).</li>
</ul>
<h2>TRChannelData.db</h2>
<p>The database template <code>TRChannelData.db</code> provides waveform records for channel data, relying on the AreaDetector StdArrays plugin. It requires the following macros:</p><ul>
<li><code>PREFIX</code>: Prefix of records (a colon is implied), this should include identification of the channel.</li>
<li><code>STDAR_PORT</code>: Name of the stdarrays port for the channel.</li>
<li><code>SIZE</code>: Waveform size (NELM).</li>
<li><code>SNAP_SCAN</code>: SCAN rate for updating the data snapshot (e.g. "1 second"). Needed only if <code>SNAPSHOT</code> is enabled which is the default.</li>
</ul>
<p>Optional macros are:</p><ul>
<li><code>FTVL</code>: Waveform data type (FTVL) (default: DOUBLE).</li>
<li><code>WF_DTYP</code>: Device support type for the data waveform, must correspond to <code>FTVL</code> (default: asynFloat64ArrayIn).</li>
<li><code>TIMESTAMP_FMT</code>: Timestamp format for <code>DATA_TIMESTAMP</code> and <code>DATA_SNAPSHOT_TIMESTAMP</code> if enabled (default: <code>Y-m-d H:M:S.%06f</code>).</li>
<li><code>SNAPSHOT</code>: Set to <code>#</code> to disable data snapshot (default: empty - enabled).</li>
<li><code>TIMESTAMP</code>: Set to empty to disable timestamp records (default: # - disabled).</li>
<li><code>DATA_UPD_LNK</code>: Record to process when the data waveform is updated (default: empty).</li>
<li><code>SNAP_UPD_LNK</code>: Record to process when the snapshot waveform is updated (default: empty).</li>
</ul>
<h2>Driver-specific DB templates</h2>
<p>Each driver will need to provide one or more database templates of its own, supporting configuration parameters and other functions specific to the driver.</p>
<p>For each configuration parameter defined by the driver (initialized by <a class="el" href="classTRBaseDriver.html#a1ffec79dcf8c5fb8ba5ffd3ce87c121f">TRBaseDriver::initConfigParam</a>), two records should be defined: an output record for the desired value and an input record for the effective value. The asyn parameter names of these will based on the base parameter name, by prepending the prefix <code>DESIRED_</code> or <code>EFFECTIVE_</code>. The records in <code>TRBase.db</code> can be used as an example.</p>
<h1>List of PVs</h1>
<ul>
<li><a class="el" href="framework-pvs.html">List of Framework PVs</a></li>
<li><a class="el" href="genstds-pvs.html">List of General Standards PVs</a></li>
<li><a class="el" href="sis3302-driver.html">SIS3302 Digitizer Driver</a> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
